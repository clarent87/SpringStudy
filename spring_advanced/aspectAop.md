# @Aspect AOP

쫌.. 어렵네..

## @Aspect 프록시 - 적용

- 개요
  - @Aspect 소개

- @Aspect 란?
  - 스프링은 @Aspect 애노테이션으로 매우 편리하게
    포인트컷과 어드바이스로 구성되어 있는 어드바이저 생성 기능을 지원
  - @Aspect 는 **관점 지향 프로그래밍(AOP)**을 가능하게 하는 AspectJ 프로젝트에서  
    제공하는 애노테이션이다. 스프링은 이것을 차용해서 프록시를 통한 AOP를 가능하게 한다

- 정리
  - @Aspect : 애노테이션 기반 프록시를 적용할 때 필요하다.
  - `@Around("execution(* hello.proxy.app..*(..))")`
    - @Around 의 값에 포인트컷 표현식을 넣는다. 표현식은 AspectJ 표현식을 사용한다.
    - **@Around 의 메서드는 어드바이스( Advice )가 된다**.
  - `ProceedingJoinPoint joinPoint`
    - 어드바이스에서 살펴본 MethodInvocation invocation 과 유사한 기능이다.
    - 내부에 실제 호출 대상, 전달 인자, 그리고 어떤 객체와 어떤 메서드가 호출되었는지 정보가 포함되어 있다.
  - `joinPoint.proceed()`
    - 실제 호출 대상( target )을 호출한다

- 의견
  - LogTraceAspect class에 주석을 많이 달았음. 이거를 꼭 참조

## @Aspect 프록시 - 설명 (5)

- 개요
  - 앞서 소개한 @Aspect 가 실제로 어떻게 advisor를 만들어 내는지 원리를 소개

- 포인트
  - 예제에서 @Aspect를 사용한 LogTraceAspect 객체를 빈으로 등록하는데..
  - 이떄 AnnotationAwareAspectJAutoProxyCreator 가 동작하여 (이거 빈 후처리기 니까..)
  - @Aspect 를 인식해서 advisor를 만들어저 저장해줌. ~~해당 빈 대신 등록한다는말~~
  - 이후 AnnotationAwareAspectJAutoProxyCreator(자동 프록시 생성기) 는
  - 등록된 advisor 빈을 모든 빈들에 적용해서 proxy를 만든다.
    - > 참고로.. advisor빈 일반 빈등등.. 우선순위가 있어서 이런 형태의 동작이 가능
  - 더욱 자세하고 정확한 내용은 pdf 참조..

여기는 pdf가 중요하고 내용도 자세하다.

- 중요 포인트
  - > 빈 등록이 아래와 같이 두단계가 되나봄
  - 1. @Aspect 를 어드바이저로 변환해서 저장하는 과정
    - > pdf에 그림 있음. 이 단계는 @Aspect 붙은 빈들을 먼저 스캔해서 스프링 컨테이너에 저장하나봄
    - > 그래서 얘네들을 가지고 @Apect 어드바이져 빌더가 advisor를 만드는듯
  - 2. 어드바이저를 기반으로 프록시 생성
    - > 이후 빈들은 pdf에 여기 내용대로..
  - > 근데 여기서는 두단계로 나누어진 것처럼 이해했는데, 생각해보면 그냥 한단계가 맞을듯.
  - > 이를테면 bean scan하고 우선순위 높은 @Aspect 붙은 애들을 빈후처리기(AnnotationAwareAspectJAutoProxyCreator)로 먼저 
  - > 처리 하고, 처리 이후 우선순위 낮은 bean들을 처리하는듯.. 그러면 위와 같은 두단계 느낌의 그림이 되니깐
  
- Q/A
  - 1. 자동 프록시 생성기가 빈 저장소에 있는 어드바이저 빈들을 조회하기 전에 모든 @Aspect 빈을 조회해서 어드바이저를 생성하여 등록하는 것은 이해가 됐습니다. 근데 그렇게 생성된 어드바이저를 왜 빈 저장소에 넣지 않고 굳이 @Aspect 어드바이저 빌더 내부 저장소에서 따로 관리를 하는 것인지 궁금합니다.
    -> 스프링 빈으로 등록하게 되면 기존 빈과 충돌할 수도 있고, 사용자가 해당 빈을 꺼낼 수도 있습니다. 그런데 사실 이 빈을 사용자가 꺼내서 사용할 일은 없지요. 스프링 입장에서는 스프링 빈에 등록해도 얻는 이점이 없기 때문에 빈으로 등록하지 않았을 것이라 생각합니다.

  - 2. @Aspect 어드바이저 빌더 내부 저장소에 캐싱이 적용된다고 하셨는데 그렇다는 것은 하나의 @Aspect 빈에서 똑같은 어드바이저를 여러번 생성하는 경우가 발생한다고 이해가 됩니다. 예를 들어 어떤 경우에 캐시에 저장된 어드바이저를 반환하게 되는지 궁금합니다. 혹시나 @Aspect 어드바이저 빌더 내부 저장소의 어드바이저들은 영속성을 가지는 것인지 의문이 드네요.
    -> AOP를 적용할 대상이 10개라면 처음에는 빌더를 통해서 어드바이저를 만들겠지만, 이후에는 이미 만들어진 어드바이저를 재활용하게 됩니다.

## 정리 (7)

@Aspect 를 사용해서 애노테이션 기반 프록시를 매우 편리하게 적용해보았다. 실무에서 프록시를 적용할
때는 대부분이 이 방식을 사용한다