# 빈후처리기

## 빈후처리기 - 소개

- 개요
  - 빈후처리기(BeanPostProcessor) 개념 소개
  - > PostConstruct 랑은 다른 개념 같은데..

## 빈후처리기 - 예제 코드1 (3)

- 개요
  - BasicTest 에 빈 후처리기를 위한 예시 만듬
  - > 과거 내용의 복습인데 중요하니까 잘 봐둬야함. 주석에 내용 적음

## 빈후처리기 - 예제 코드2 (5)

- 개요
  - 위에서 만든 예제에 빈 후처리기 등록
  - > beanA 등록되는것을 beanB가 등록되도록 후킹하는듯.

- 중요 포인트
  - 빈 후처리기를 사용하려면 BeanPostProcessor 인터페이스를 구현하고, 스프링 빈으로 등록하면 된다.
  - postProcessBeforeInitialization
    - 객체 생성 이후에 `@PostConstruct` 같은 초기화가 발생하기 전에 호출되는 포스트 프로세서이다.
  - postProcessAfterInitialization
    - 객체 생성 이후에`@PostConstruct` 같은 초기화가 발생한 다음에 호출되는 포스트 프로세서이다
  - > bean life 사이클에서 postconstuct 이후 컨테이너에 빈 등록되는게 아닌가 싶네.. 👍

- 중요 포인트2
  - 빈 후처리기는 빈을 조작하고 변경할 수 있는 후킹 포인트이다.
  - 이것은 빈 객체를 조작하거나 심지어 다른 객체로 바꾸어 버릴 수 있을 정도로 막강하다.
  - 여기서 조작이라는 것은 해당 객체의 특정 메서드를 호출하는 것을 뜻한다.
    - > 즉, setter를 호출해서 의존성을 주입하던가.. 등
  - 일반적으로 스프링 컨테이너가 등록하는, 특히 컴포넌트 스캔의 대상이 되는 빈들은 중간에 조작할 방법이 없는데,
  - 빈 후처리기를 사용하면 개발자가 등록하는 모든 빈을 중간에 조작할 수 있다.
  - 이 말은 빈 객체를 프록시로 교체하는 것도 가능하다는 뜻이다.

- 중요 포인트 3 👍
  - 타겟 빈 등록 + 빈 후처리기 빈 등록 을 config에서 진행하는데
  - 혹시 타겟 빈이 먼저 등록되면, 빈 후처리기가 동작 안할까?? 
    - 당연히 아니다. 빈 후처리기가 빈 등록전에 동작하도록 스프링이 알아서 해준다.!!
    - > postProcessor가 우선순위가 높나봄..  빈후처리기 - 적용 11:36에서도 그런 언급이 잠깐 나옴

- 중요 사실!
  - 스프링은 CommonAnnotationBeanPostProcessor 라는 빈 후처리기를 자동으로 등록하는데,
  - 이게 빈의 생성후 @PostConstruct 애노테이션이 붙은 메서드를 호출한다
  - > CommonAnnotationBeanPostProcessor 랑 BeanPostProcessor 는 쫌 다른거 같은데.. 여튼 복잡하니 넘어감.
  - > BeanPostProcessor는 초기화 이후 동작하고 CommonAnnotationBeanPostProcessor는 빈 생성후 동작 같아서 다르다고 생각함

- 기타
  - 등록한 빈 후처리기 순서 조작
  - <https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/config/BeanPostProcessor.html>

## 빈후처리기 - 적용 (9)

- 개요
  - 빈 후처리기를 사용해서 실제 객체 대신 프록시를 스프링 빈으로 등록
  - 이렇게 하면 수동으로 등록하는 빈은 물론이고,
  - 컴포넌트 스캔을 사용하는 빈까지 모두 프록시를 적용할 수 있다.
  - 더 나아가서 설정 파일에 있는 수 많은 프록시 생성 코드도 한번에 제거할 수 있다.
  - 작업
    - config 패키지에 v4~ 만들고 PackageLogTraceProxyPostProcessor class를 만들었음

- 간단 정리
  - 기존에는 bean에 프록시 팩토리 적용하느라 config 파일 만들고, 빈마다 프록시 팩토리로 프록시 생성했는데.
  - 빈 후처리기를 이용하니 그럴 필요가 없어 졌음
  - 그리고 component scan으로 등록되는 빈도 프록시를 생성해 줄수 있게 되었음

- 포인트

    ```java
            // [*] 여기서 스프링이 등록하는 모든 bean들이 넘어오기 때문에, 어떤 bean들이 등록되는지 볼수도 있음
            log.info("param beanName={} bean={}", beanName, bean.getClass());
    ```

- 중요 포인트
  - 앞서 나온 내용인데 class가 final인 애들은 proxy생성 못함.. 당연히.. 
  - 이 애들을 대상으로 proxyFactory쓰면 에러 날듯.. 
    - 그래서 빈 후처리기 사용시 적용 bean을 패키지 단위로 거른 느낌...
    - > 아마 어노테이션 기반으로 거를수도 있을듯.. bean의 정보 확인 해서

- 중요 포인트2
  - 여기서는 package 이름으로 빈 후처리 적용할 bean을 걸렀는데.. 
  - 그냥 포인트컷을 이용해도 된다고 함.. 
    - > advice를 적용할지 말지 결정하는게  포인트 컷이었음
    - > NameMatchMethodPointcut 같은 포인트 컷으로 등록한 method name에 대해서만 advice를 적용했는데
    - > 아마 final class는 걸러주는 포인트 컷도 있을듯? 
    - > 근데 proxyFactory는 일단 proxy를 만드는거 아닌가.... 의문임 👍

- 기타 의견
  - 포인트컷 만드는거 remaind 필요.. 까먹겠음..
  - 그리고 어드바이스는 MethodInterceptor impl인거 기억하고.. 까먹껬음

- 리마인드 필요
  - 포인트컷 직접만든것도 잇음

## 빈후처리기 - 정리 (14)

## 스프링이 제공하는 빈 후처리기1

## 스프링이 제공하는 빈 후처리기2

## 하나의 프록시 여러개의 advisor 적용

## 정리
