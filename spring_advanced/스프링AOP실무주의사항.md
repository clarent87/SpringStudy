# 스프링 AOP - 실무 주의 사항

아래 두가지 문제에 대해서 다루는 강좌

- 프록시와 내부 호출
- 프록시 기술과 한계

## 프록시와 내부 호출 - 문제

실무에서 반드시 한번은 겪는 문제라고 한다.  

- 개요
  - 여지껏 나온 개념이긴 하다
  - 프록시가 적용되려면 항상 프록시 객체를 통해 method를 호출해야함
  - 즉, target 객체를 이용해서 method를 호출하면 당연히 advice는 적용이 안된채로 호출됨.
  - CallServiceV0Test class 및 기타 클래스를 통해 문제를 보임

- 포인트
  - 아래 external, internal 모두 advisor가 걸린 상태인데, external 호출시, method내부에서 호출하는 internal은 this.internal
  - 즉, proxy의 target 객체라서 advisor가 걸린게 호출되는게 아님.

  ```java
    public void external() {
        log.info("call external");
        internal(); //내부 메서드 호출(this.internal())
                    // java에서 this.internal()로 호출해 준다. -> 바이트코드상 당연한 얘기
    }

    public void internal() {
        log.info("call internal");
    }
  ```

요거 면접때 물어본다함
  
- 프록시 방식의 AOP 한계 👍
  - 스프링은 프록시 방식의 AOP를 사용한다.
  - 프록시 방식의 AOP는 메서드 내부 호출에 프록시를 적용할 수 없다.
  - 지금부터 이 문제를 해결하는 방법을 하나씩 알아보자

- 참고(중요) 👍
  - 실제 코드에 AOP를 직접 적용하는 AspectJ를 사용하면 이런 문제가 발생하지 않는다.
  - 프록시를 통하는 것이 아니라 해당 코드에 직접 AOP 적용 코드가 붙어 있기 때문에 내부 호출과 무관하게 AOP를 적용할 수 있다.
  - 하지만 로드 타임 위빙 등을 사용해야 하는데, 설정이 복잡하고 JVM 옵션을 주어야 하는 부담이 있다.
  - 그리고 지금부터 설명할 프록시 방식의 AOP에서 내**부 호출에 대응할 수 있는 대안**들도 있다.
    - 이런 이유로 AspectJ를 직접 사용하는 방법은 실무에서는 거의 사용하지 않는다.
    - 스프링 애플리케이션과 함께 직접 AspectJ 사용하는 방법은 스프링 공식 메뉴얼을 참고하자.
    - <https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-using-aspectj>

## 프록시와 내부 호출 - 대안1 자기 자신 주입 (5)

- 개요
  - 내부 호출 문제 해결책 첫번째
  - 그냥 자기 자신(proxy적용된) 것을 주입받아서 해당 객체의 method를 호출

- 포인트 👍
  - 참고로 이 경우 생성자 주입시 오류가 발생한다.
  - 본인을 생성하면서 주입해야 하기 때문에 순환 사이클이 만들어진다.
  - 반면에 수정자 주입은 스프링이 생성된 이후에 주입할 수 있기 때문에 오류가 발생하지 않는다.
    - > 스프링이 생성된 이후 -> 빈 생성 이후를 말하는듯.
  - > 그래서 CallServiceV1 예시에서 세터 주입을 받았음

스프링은 빈 생성하는단계, 세터 주입 단계가 분리 되어 있다고함  

- 주의 👍
  - 스프링 부트 2.6부터는 순환 참조를 기본적으로 금지하도록 정책이 변경되었다.
    - <https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.6-Release-Notes>
  - 따라서 이번 예제를 스프링 부트 2.6 이상의 버전에서 실행하면 다음과 같은 오류 메시지가 나오면서 정상 실행되지 않는다.
  - 이 문제를 해결하려면 application.properties 에 다음을 추가해야 한다.
  - `spring.main.allow-circular-references=true`

## 프록시와 내부 호출 - 대안2 지연 조회 (8)

- 개요
  - 앞서 생성자 주입은 순환 참조때문에 되지 않았다. 그래서 setter 주입으로 이문제를 해결했는데 
  - 이 문제 해결 방식은 "지연 조회" 방식도 있다 

- 지연 조회
  - 스프링 빈을 지연해서 조회하면 되는데, ObjectProvider(Provider) , ApplicationContext 를 사용하면 된다.
  - > 기본편에 나온 내용이라고 함 --> 맞네

근데 대안1,2는 뭔가 억지로 문제를 해결하는 느낌. 그래서 대안3이 나옴

## 프록시와 내부 호출 - 대안3 구조 변경 (10)

- 개요 👍 
  - 앞선 방법들은 자기 자신을 주입하거나 또는 Provider 를 사용해야 하는 것 처럼 조금 어색한 모습을 만들었다.
  - 가장 나은 대안은 내부 호출이 발생하지 않도록 구조를 변경하는 것이다. 실제 이 방법을 가장 권장한다
  - > 스프링에서도 권장하는 방법이고, 김영한 님도 주로 이방법을 쓴다함
  - 여기서 구조를 변경한다는 것은 여기 예시처럼 단순하게 분리하는 것 뿐만 아니라 다양한 방법들이 있을 수 있다.

- 포인트
  - 내가 생각한 방법과 일치
  - 그냥 internal method를 따로 class로 만들고 bean으로 등록, 그리고 그럴 주입 받아서 사용

- 의견 ( 이건 순전히 내의견 )
  - private method에 aop 적용하고 싶다면?
    - private method는 그냥 두고 body 로직을 따로 함수로 만들고 그걸 빼서 class로 만들고 빈등록
    - 이걸 private method body에서 가져와서 사용하는 방법 어떨지.

- 참고 ( 매우 중요 ) 👍 👍
  - AOP는 주로 트랜잭션 적용이나 주요 컴포넌트의 로그 출력 기능에 사용된다.
  - 쉽게 이야기해서 인터페이스에 메서드가 나올 정도의 규모에 AOP를 적용하는 것이 적당하다.
  - 더 풀어서 이야기하면 **AOP는 public 메서드**에만 적용한다.
  - private 메서드처럼 작은 단위에는 AOP를 적용하지 않는다.
    - > 적용되지도 않는다고 언급
  - 따라서 AOP 적용을 위해 private 메서드를 외부 클래스로 변경하고 public 으로 변경하는 일은 거의 없다. 💯
  - 그러나 위 예제와 같이 public 메서드에서 public 메서드를 내부 호출하는 경우에는 문제가 발생한다.
  - 실무에서 꼭 한번은 만나는 문제이기에 이번 강의에서 다루었다. 
  - AOP가 잘 적용되지 않으면 내부 호출을 의심해보자.

근데 실무에서는 반드시 대안3이 답인건 아닐수 있음. 대안 1,2 도 선택가능한 옵션임을 강의 마지막에 언급

- Q/A
  - 스프링 트랜잭션의 경우 checkedException에서는 예외가 발생하더라도 롤백시키지 않습니다
  - > 여기 내용이랑은 직접 관련은 없는데, 일단 적어둠

## 프록시 기술과 한계 - 타입 캐스팅

## 프록시 기술과 한계 - 의존관계 주입

## 프록시 기술과 한계 - CGLIB

## 프록시 기술과 한계 - 스프링의 해결책

## 정리
