# 스프링 AOP - 실무 주의 사항

아래 두가지 문제에 대해서 다루는 강좌

- 프록시와 내부 호출
- 프록시 기술과 한계

## 프록시와 내부 호출 - 문제

실무에서 반드시 한번은 겪는 문제라고 한다.  

- 개요
  - 여지껏 나온 개념이긴 하다
  - 프록시가 적용되려면 항상 프록시 객체를 통해 method를 호출해야함
  - 즉, target 객체를 이용해서 method를 호출하면 당연히 advice는 적용이 안된채로 호출됨.
  - CallServiceV0Test class 및 기타 클래스를 통해 문제를 보임

- 포인트
  - 아래 external, internal 모두 advisor가 걸린 상태인데, external 호출시, method내부에서 호출하는 internal은 this.internal
  - 즉, proxy의 target 객체라서 advisor가 걸린게 호출되는게 아님.

  ```java
    public void external() {
        log.info("call external");
        internal(); //내부 메서드 호출(this.internal())
                    // java에서 this.internal()로 호출해 준다. -> 바이트코드상 당연한 얘기
    }

    public void internal() {
        log.info("call internal");
    }
  ```

요거 면접때 물어본다함
  
- 프록시 방식의 AOP 한계 👍
  - 스프링은 프록시 방식의 AOP를 사용한다.
  - 프록시 방식의 AOP는 메서드 내부 호출에 프록시를 적용할 수 없다.
  - 지금부터 이 문제를 해결하는 방법을 하나씩 알아보자

- 참고(중요) 👍
  - 실제 코드에 AOP를 직접 적용하는 AspectJ를 사용하면 이런 문제가 발생하지 않는다.
  - 프록시를 통하는 것이 아니라 해당 코드에 직접 AOP 적용 코드가 붙어 있기 때문에 내부 호출과 무관하게 AOP를 적용할 수 있다.
  - 하지만 로드 타임 위빙 등을 사용해야 하는데, 설정이 복잡하고 JVM 옵션을 주어야 하는 부담이 있다.
  - 그리고 지금부터 설명할 프록시 방식의 AOP에서 내**부 호출에 대응할 수 있는 대안**들도 있다.
    - 이런 이유로 AspectJ를 직접 사용하는 방법은 실무에서는 거의 사용하지 않는다.
    - 스프링 애플리케이션과 함께 직접 AspectJ 사용하는 방법은 스프링 공식 메뉴얼을 참고하자.
    - <https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-using-aspectj>

## 프록시와 내부 호출 - 대안1 자기 자신 주입 (5)

- 개요
  - 내부 호출 문제 해결책 첫번째
  - 그냥 자기 자신(proxy적용된) 것을 주입받아서 해당 객체의 method를 호출

- 포인트 👍
  - 참고로 이 경우 생성자 주입시 오류가 발생한다.
  - 본인을 생성하면서 주입해야 하기 때문에 순환 사이클이 만들어진다.
  - 반면에 수정자 주입은 스프링이 생성된 이후에 주입할 수 있기 때문에 오류가 발생하지 않는다.
    - > 스프링이 생성된 이후 -> 빈 생성 이후를 말하는듯.
  - > 그래서 CallServiceV1 예시에서 세터 주입을 받았음

스프링은 빈 생성하는단계, 세터 주입 단계가 분리 되어 있다고함  

- 주의 👍
  - 스프링 부트 2.6부터는 순환 참조를 기본적으로 금지하도록 정책이 변경되었다.
    - <https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.6-Release-Notes>
  - 따라서 이번 예제를 스프링 부트 2.6 이상의 버전에서 실행하면 다음과 같은 오류 메시지가 나오면서 정상 실행되지 않는다.
  - 이 문제를 해결하려면 application.properties 에 다음을 추가해야 한다.
  - `spring.main.allow-circular-references=true`

## 프록시와 내부 호출 - 대안2 지연 조회 (8)

- 개요
  - 앞서 생성자 주입은 순환 참조때문에 되지 않았다. 그래서 setter 주입으로 이문제를 해결했는데
  - 이 문제 해결 방식은 "지연 조회" 방식도 있다

- 지연 조회
  - 스프링 빈을 지연해서 조회하면 되는데, ObjectProvider(Provider) , ApplicationContext 를 사용하면 된다.
  - > 기본편에 나온 내용이라고 함 --> 맞네

근데 대안1,2는 뭔가 억지로 문제를 해결하는 느낌. 그래서 대안3이 나옴

## 프록시와 내부 호출 - 대안3 구조 변경 (10)

- 개요 👍
  - 앞선 방법들은 자기 자신을 주입하거나 또는 Provider 를 사용해야 하는 것 처럼 조금 어색한 모습을 만들었다.
  - 가장 나은 대안은 내부 호출이 발생하지 않도록 구조를 변경하는 것이다. 실제 이 방법을 가장 권장한다
  - > 스프링에서도 권장하는 방법이고, 김영한 님도 주로 이방법을 쓴다함
  - 여기서 구조를 변경한다는 것은 여기 예시처럼 단순하게 분리하는 것 뿐만 아니라 다양한 방법들이 있을 수 있다.

- 포인트
  - 내가 생각한 방법과 일치
  - 그냥 internal method를 따로 class로 만들고 bean으로 등록, 그리고 그럴 주입 받아서 사용

- 의견 ( 이건 순전히 내의견 )
  - private method에 aop 적용하고 싶다면?
    - private method는 그냥 두고 body 로직을 따로 함수로 만들고 그걸 빼서 class로 만들고 빈등록
    - 이걸 private method body에서 가져와서 사용하는 방법 어떨지.

- 참고 ( 매우 중요 ) 👍 👍
  - AOP는 주로 트랜잭션 적용이나 주요 컴포넌트의 로그 출력 기능에 사용된다.
  - 쉽게 이야기해서 인터페이스에 메서드가 나올 정도의 규모에 AOP를 적용하는 것이 적당하다.
  - 더 풀어서 이야기하면 **AOP는 public 메서드**에만 적용한다.
  - private 메서드처럼 작은 단위에는 AOP를 적용하지 않는다.
    - > 적용되지도 않는다고 언급
  - 따라서 AOP 적용을 위해 private 메서드를 외부 클래스로 변경하고 public 으로 변경하는 일은 거의 없다. 💯
  - 그러나 위 예제와 같이 public 메서드에서 public 메서드를 내부 호출하는 경우에는 문제가 발생한다.
  - 실무에서 꼭 한번은 만나는 문제이기에 이번 강의에서 다루었다.
  - AOP가 잘 적용되지 않으면 내부 호출을 의심해보자.

근데 실무에서는 반드시 대안3이 답인건 아닐수 있음. 대안 1,2 도 선택가능한 옵션임을 강의 마지막에 언급

- Q/A
  - 스프링 트랜잭션의 경우 checkedException에서는 예외가 발생하더라도 롤백시키지 않습니다
  - > 여기 내용이랑은 직접 관련은 없는데, 일단 적어둠

## 프록시 기술과 한계 - 타입 캐스팅 (14)

- 개요
  - JDK 프록시의 단점에 대해 소개 한다.

- 정리
  - JDK 동적 프록시는 대상 객체인 MemberServiceImpl 로 캐스팅 할 수 없다.
  - CGLIB 프록시는 대상 객체인 MemberServiceImpl 로 캐스팅 할 수 **있다.**
  - 그런데 프록시를 캐스팅 할 일이 많지 않을 것 같은데 왜 이 이야기를 하는 것일까?
  - 진짜 문제는 의존관계 주입시에 발생한다.

- 포인트
  - assertThatThrownBy 란 함수로 test code짠부분 있었음
  - > 그냥 알아두면 좋을거 같아서 작성함

## 프록시 기술과 한계 - 의존관계 주입 (18)

- 개요
  - JDK 동적 프록시를 사용하면서 의존관계 주입을 할 때 문제 발생
  - 즉, 인터페이스 기반으로 프록시가 생성되기 때문에 MemberServiceImpl 같은 구체 클래스로 대해서 DI/타입캐스팅을 진행할수 없다.

- 정리
  - JDK 동적 프록시는 대상 객체인 MemberServiceImpl 타입에 의존관계를 주입할 수 없다.
  - CGLIB 프록시는 대상 객체인 MemberServiceImpl 타입에 의존관계 주입을 할 수 있다.
  - 지금까지 JDK 동적 프록시가 가지는 한계점을 알아보았다.
  - 실제로 개발할 때는 인터페이스가 있으면 인터페이스를 기반으로 의존관계 주입을 받는 것이 맞다.
  - **DI의 장점이 무엇인가? DI 받는 클라이언트 코드의 변경 없이 구현 클래스를 변경할 수 있는 것이다.**
  - 이렇게 하려면 인터페이스를 기반으로 의존관계를 주입 받아야 한다.
  - MemberServiceImpl 타입으로 의존관계 주입을 받는 것 처럼 구현 클래스에 의존관계를 주입하면
  - 향후 구현 클래스를 변경할 때 의존관계 주입을 받는 클라이언트의 코드도 함께 변경해야 한다.
  - **따라서 올바르게 잘 설계된 애플리케이션이라면 이런 문제가 자주 발생하지는 않는다.**
  - 그럼에도 불구하고 테스트, 또는 여러가지 이유로 AOP 프록시가 적용된 구체 클래스를 직접 의존관계 주입 받아야 하는 경우가 있을 수 있다.
  - 이때는 CGLIB를 통해 구체 클래스 기반으로 AOP 프록시를 적용하면 된다.

다음 절은 CGLIB의 한계에 대해 기술

## 프록시 기술과 한계 - CGLIB

- 개요
  - 이번절은 코드는 없다.

- CGLIB는 구체 클래스를 상속 받기 때문에 다음과 같은 문제가 있다.
- CGLIB 구체 클래스 기반 프록시 문제점
  - 대상 클래스에 기본 생성자 필수
    - > 아니던데.... 예시중에서 기본 생성자가 없어도 proxyFactory로 cgblig적용한 예가 있음
  - 생성자 2번 호출 문제
    - target 객체 생성때, 그리고 proxy 생성될때
  - final 키워드 클래스, 메서드 사용 불가

- 포인트
  - 프레임워크 같은 개발이 아니라 일반적인 웹 애플리케이션을 개발할 때는 final 키워드를 잘 사용하지 않는다.
  - 따라서 이 부분이 특별히 문제가 되지는 않는다.
    - > final 키워드 클래스, 메서드 사용 불가
    - > final 키워드가 클래스에 있으면 상속이 불가능하고, 메서드에 있으면 오버라이딩이 불가능하다. 
    - > CGLIB는 상속을 기반으로 하기 때문에 두 경우 프록시가 생성되지 않거나 정상 동작하지 않는다.

## 프록시 기술과 한계 - 스프링의 해결책 (23)

- CGLIB 기본 생성자 필수 문제 해결 👍 👍 👍
  - 스프링 4.0부터 CGLIB의 기본 생성자가 필수인 문제가 해결되었다.
  - objenesis 라는 특별한 라이브러리를 사용해서 기본 생성자 없이 객체 생성이 가능하다.
  - 참고로 이 라이브러리는 **생성자 호출 없이 객체를 생성**할 수 있게 해준다.

- 생성자 2번 호출 문제
  - 스프링 4.0부터 CGLIB의 생성자 2번 호출 문제가 해결되었다. 
  - 이것도 역시 objenesis 라는 특별한 라이브러리 덕분에 가능해졌다. 이제 생성자가 1번만 호출된다
  - > 즉 프록시 객체 생성할때 생성자 호출 없이 객체를 생성

- 스프링 부트 2.0 - CGLIB 기본 사용
  - 스프링 부트 2.0 버전부터 CGLIB를 기본으로 사용하도록 했다.
  - 이렇게 해서 구체 클래스 타입으로 의존관계를 주입하는 문제를 해결했음
    - > 즉 jdk proxy의 구체 클래스 타입 의존 안되는 문제를 걍 CGLIB 이용하는것으로 때웠다는 말
  - > 스프링 부트 2.0이라는게 중요. 스프링이 아니라


- Q/A
  - JPA 도 프록시로 인해서 기본생성자가 필요하다는 점이 생각나서 보았더니 리플레션을 통해서 생성하기 때문에 기본생성자가 필요한 것으로 보였습니다. 
  - 추측 근거: `org.hibernate.bytecode.internal.javassist.FastClass.newInstance(int index, Object[] args)` 메소드를 참고하였습니다.
  - 근데 왜 `objenesis` 를 사용하면 되는데, JPA 에선 왜 POJO 스타일의 리플렉션을 사용하는지 궁금합니다.
  - 답변
    - JPA 스펙은 하이버네이트와 같은 특정 기술을 위한 것이 아니라 범용성 있게 설계된 것입니다.
    - 과거 JPA 스펙을 지정할 때는 objenesis 같은 것이 없었지요

## 정리

## 내가 추가함

- spring aop를 이용한경우 proxy 적용된 class의 method에서 this를 return하면 target instance가 return 되는것이 아닌
- proxy가 return 된다.
- > this값이 method 내에서는 target을 가리키는데, return 이후에는 proxy의 값으로 변경됨