# 스프링이 지원하는 프록시

## 프록시 팩토리 - 소개

- 개요 
  - 프록시 팩토리 소개

- 중요 포인트
  -  프록시 팩토리는 인터페이스가 있으면 JDK 동적 프록시를 사용하고,
  -  구체 클래스만 있다면 CGLIB를사용한다. 그리고 이 설정을 변경할 수도 있다.
  -  > 내가 쓴 Async는 interface가 있었기 떄문에 interface기반 proxy인 jdk 프록시가 적용된거 아닐까..

- 중요 포인트
  - 특정 조건에 맞을 때 프록시 로직을 적용하는 기능도 공통으로 제공되었으면?
  - 앞서 특정 메서드 이름의 조건에 맞을 때만 프록시 부가 기능이 적용되는 코드를 직접 만들었다.
  -  스프링은 Pointcut 이라는 개념을 도입해서 이 문제를 일관성 있게 해결한다.

- 의견
  - 3page 그림 보는게 낫다. 

## 프록시 팩토리 - 예제 코드 1 (3)

- 개요
  - Advice 는 프록시에 적용하는 부가 기능 로직이다.
  -  이것은 JDK 동적 프록시가 제공하는 InvocationHandler 와 CGLIB가 제공하는 MethodInterceptor 의 개념과 유사한다. 
  -  둘을 개념적으로 추상화 한 것이다. 프록시 팩토리를 사용하면 둘 대신에 Advice 를 사용하면 된다

여기는 그냥 pdf 보는게 낫다. 내용이 많음. 그리고 다 중요함

- 포인트
  - MethodInterceptor는 advice라고 부른다. 
    - > MethodInterceptor가 advice를 상속하고 있어서. 여기서 MethodInterceptor는 CGLIb 말고 AOP의 꺼

- 포인트2
  - proxyfactory 예시에서 보면 interface가 있는 serviceImple을 target으로 사용하였기 때문에
  - proxy에는 jdk dynamic proxy가 사용됨
  - 따라서 `proxyClass=class jdk.proxy2.$Proxy10` 라는 이름으로 프록시가 만들어진것을 알수 잇음

- 포인트3
  - `AopUtils` 는 proxyfactory를 이용해서 만든 proxy를 대상으로만 사용가능
  - 즉 내가 CGLIB이나 jdk proxy로 만든 proxy에는 사용할수 없다. 


## 프록시 팩토리 - 예제 코드 2 (7)

- 개요
  - proxyfactory를 이용해서 예제 코드 1에서는 interface 기반 impl를 target으로 적용해봄
  - 여기서는 구체 클래스를 대상으로 적용해봄
  - 그리고 인터페이스가 있어도 CGLIB이 적용되게 proxyfactory 세팅해봄

- 구체클래스 대상 proxyfactory 적용
  - 적용후 생성된 proxy이름은 다음과 같다. 
  - `proxyClass=class hello.proxy.common.service.ConcreteService$$EnhancerBySpringCGLIB$$53a6cbfd`  
  - 즉 구체 클래스를 타겟으로 했기 때문에 cglib이 적용된것을 알수 있음

- interface 기반 target이어도 cglib 적용
  - `proxyFactory.setProxyTargetClass(true);` 를 세팅해 주면 된다.
    - > 이거 중요하다고 함. spring 실무에서 한번씩 등장한다고 함
  - setProxy TargetClass 즉 targetclass 기반으로 proxy를 만든다는것. target의 class 기반~
  - 만들어진 proxy 이름
    - `proxyClass=class hello.proxy.common.service.ServiceImpl$$EnhancerBySpringCGLIB$$6526a44f`
    - 보면 ServiceImpl 를 기반으로 만들어진것을 알수 있음
    - 참고로 `ServiceImpl$$EnhancerBySpringCGLIB$$6526a44f`가 동적 생성된 class 이름.

- 중요!!
  - 스프링 부트(최근 스프링부트를 말함 2.0이후)는 AOP를 적용할 때 기본적으로 proxyTargetClass=true 로 설정해서 사용한다.
  - 따라서 인터페이스가 있어도 항상 CGLIB를 사용해서 구체 클래스를 기반으로 프록시를 생성한다.
  - 자세한 이유는 강의 뒷 부분에서 설명한다.
  - > 근데 내가 @Async interface에 썻을떈 cglib아니었떤거 같은데....


- 의견
  - 동적 생성되는 proxy 이름 규칙에서 `$$` 는 상속을 의미하고 `$`는 구현을 의미하는거 아닐까 싶네...


## 포인트 컷, 어드바이스, 어드바이저 - 소개

## 예제코드1 - 어드바이저

## 예제코드2 - 직접만든 포인트 컷

## 예제코드3 - 스프링이 제공하는 포인트 컷

## 예제코드4 - 여러 어드바이저 함꼐 적용

## 프록시 팩토리 - 적용1

## 프록시 팩토리 - 적용2

## 정리
