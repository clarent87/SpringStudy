# 템플릿메서드 패턴과 콜백 패턴

## 템플릿 메서드 패턴 - 시작

- 개요
  - 앞선 app v3의 단점 소개
  - 템플릿 메서드 패턴 간략 소개

- 의견
  - pdf 내용 좋으니 참조 요망

## 템플릿 메서드 패턴 - 예제1 (4)

- 개요
  - 핵심기능, 부가기능을 가지는 예시 만듬
  - TemplateMethodTest에 구혐

## 템플릿 메서드 패턴 - 예제2 (6)

- 개요
  - AbstractTemplate 에 템플릿 메서드 패턴 구현

- 중요 Point
  - 중복 코드를 템플릿 메서드 패턴으로 뺏기 때문에, 단일 책임 원칙 지키키가 좋음
  - 즉, 코드 수정시 한부분만 수정하면됨. 기존에는 중복 코드 전부(부가기능) 전부 찾아서 수정해야 했음
  - > 이거 코드 스멜에서 뭐였지? 수정 방법은?

## 템플릿 메서드 패턴 - 예제3 (9)

- 개요
  - 템플릿 메서드 패턴은 SubClassLogic1 , SubClassLogic2 처럼 클래스를 계속 만들어야 하는 단점이 있다.
  - 익명 내부 클래스를 사용하면 이런 단점을 보완할 수 있다
  - 그래서 익명 내부 클래스를 이용해서 templateMethodV2 test method를 만듬

- 중요 point
  - 익명 내부 클래스의 이름
    - TemplateMethodTest$1 , TemplateMethodTest$2 로 나옴
    - 즉 익명 내부 클래스를 사용한 **클래스$순서** 이런식

## 템플릿 메서드 패턴 - 적용1 (11)

- 개요
  - app -> trace -> template 에 AbstractTemplate abstract class 만듬
  - app -> v4 구현
  - 그냥 앞서 나온 템플릿 메소드 패턴을 적용한것이 전부

- point
  - 익명 inner class에서 AbstractTemplate abstract class의 contructor는 param 1개를 받는다
  - 그래서 아래처럼 trace 를 전달함

  ```java
  AbstractTemplate<String> template = new AbstractTemplate<>(trace) {
      @Override
      protected String call() {
          orderService.orderItem(itemId);
          return "ok";
      }
  };
  ```

  - AbstractTemplate<T>는 제네릭을 써서 만듬
  - Void 가 반환 타입일 경우 return null 해야 한다.

## 템플릿 메서드 패턴 - 적용2 (16)

- 개요
  - 앞서 적용한 내용을 정리 한것
  
- point
  - 좋은 설계란?
    - 코드 변경이 발생했을때 드러남
  - 단일책임원칙 (SRP)
    - 로그를 남기는 부분에 단일 책임 원칙(SRP)을 지킨 것이다. 변경 지점을 하나로 모아서
    - 변경에 쉽게 대처할 수 있는 구조를 만든 것이다

## 템플릿 메서드 패턴 - 정의 (18)

- 개요
  - 템플릿 메서드 패턴이 무엇인지 정리해줌
  - PDF 꼭 참조!!

- 중요
  - 상속의 단점이 나옴
    - 주요 단점은 부모 class가 변하면 자식 클래스에도 영향을 받음
  - 상속(템플릿 메소드 패턴) 보다 위임 (전략 패턴)을 다음 부터 소개함
  - 상속은 PDF에 나와 있듯 여러 단점이 있으므로..
  - > 보통 상속은 여기처럼 subclassing 보다는 sub-typing으로 쓰는것이 좋다고 했던거 같음.
  - > sub-typing은 interface - impl 개념임.
  - > subclassing : 코드 중복 제거, 재사용이 목표 ( 슈퍼 클래스를 대체하지 못함)
  - > sub-typing : 설계 유연성이 목표.

## 전략 패턴 - 시작 (19)

- 개요
  - 전략 패턴 소개를 위한 예제를 만듬
  - 기존 TemplateMethodTest class의 내용을 그대로 ContextV1Test로 가져옴
  - 앞으로 이것을 전략 패턴으로 푸는 방법을 소개 ( 앞선 챕터에서는 이걸 템플릿 메소드로 품 )

- 주요 포인트
  - 전략 패턴에서 Context란?
    - 거대한 문맥.. 그냥 템플릿 메소드 패턴에서의 템플릿 이라고 보면됨 ( 변하지 않는 로직 )
    - > 이중 일부의 알고리즘을 빼서 교체 가능하게 만드는게 전략 패턴..
  - 상속이랑은 다르게 interface에 의존하고 있어서 변경에 좀더 영향을 덜 받는다.
    - > 사실 인터페이스가 변경될 일은 부모 class가 변경될 일보다는 좀더 적으니까..
    - > 그리고 부모 class에는 logic이 있으니 이게 임의로 변경되면 자식에 영향이 갈수도 있는데  
    - > 인터페이스는 기본적으로 그럴일이 없음.
  - 템플릿 메소드 패턴에서는 context가 부모 클래스에 있었는데, 전략은 따로 context가 빠져 있기 때문에
  - 이게 변하던 말던, 핵심 로직에는 영향을 주지 않는다.
  - > 강좌 10분쯤에 설명이 잘 나옴. 위 글만 봐서는 장점이 애매할수 있음

## 전략 패턴 - 예제1 (20)

- 개요
  - 전략 패턴 예제를 만듬(test code에 만듬)
  - test에 strategy package아래에 코드들을 둠

- 주요 포인트
  - ContextV1 은 변하지 않는 로직을 가지고 있는 템플릿 역할을 하는 코드이다.
  - 전략 패턴에서는 이것을 컨텍스트(문맥)이라 한다.

## 전략 패턴 - 예제2 (25)

- 개요
  - 전략 패턴도 익명 내부 클래스를 사용할 수 있다. 그리고 람다도 가능
  - 그래서 ContextV1Test 에 전략패턴을 익명 내부 클래스에서 람다 까지 이용해서 만드는 법 소개 함.

- 주요 포인트
  - 강좌에서는 익명 내부 클래스로 strategy interaface의 impl을 만들었는데.
  - 나는 그냥 이거 람다로 치환했음
    - > 람다는 클래스 명이 ContextV1Test$$Lambda$316/0x0000000800cae578 이런식임..
  - 근데 다시 익명으로 원상 복구함. 강좌 따라 하려고..
  - 전략 패턴은 "선조립, 후실행" 방식 이다.
    - > 템플릿 메소드 패턴과 비교하려는건 아님. 이건 그냥 전략 패턴의 특징
  - 단점
    - 방식의 단점은 Context 와 Strategy 를 조립한 이후에는 전략을 변경하기가 번거롭다는 점이다
    - 물론 Context 에 setter 를 제공해서 Strategy 를 넘겨 받아 변경하면 되지만, Context 를 싱글톤으로
    - 사용할 때는 동시성 이슈 등 고려할 점이 많다.
    - 그래서 전략을 실시간으로 변경해야 하면 차라리 이전에 개발한 테스트 코드 처럼 Context 를 하나더 생성하고
    - 그곳에 다른 Strategy 를 주입하는 것이 더 나은 선택일 수 있다

- 의견
  - **람다로 변경하려면 인터페이스에 메서드가 1개만 있으면 되는데** 란 표현이 pdf에 있음
  - 엄밀히는 추상 메서드가 1개여야함.

## 전략 패턴 - 예제3 ()
