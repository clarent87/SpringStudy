# 템플릿메서드 패턴과 콜백 패턴

## 템플릿 메서드 패턴 - 시작

- 개요
  - 앞선 app v3의 단점 소개
  - 템플릿 메서드 패턴 간략 소개

- 의견
  - pdf 내용 좋으니 참조 요망

## 템플릿 메서드 패턴 - 예제1 (4)

- 개요
  - 핵심기능, 부가기능을 가지는 예시 만듬
  - TemplateMethodTest에 구혐

## 템플릿 메서드 패턴 - 예제2 (6)

- 개요
  - AbstractTemplate 에 템플릿 메서드 패턴 구현

- 중요 Point
  - 중복 코드를 템플릿 메서드 패턴으로 뺏기 때문에, 단일 책임 원칙 지키키가 좋음
  - 즉, 코드 수정시 한부분만 수정하면됨. 기존에는 중복 코드 전부(부가기능) 전부 찾아서 수정해야 했음
  - > 이거 코드 스멜에서 뭐였지? 수정 방법은?

## 템플릿 메서드 패턴 - 예제3 (9)

- 개요
  - 템플릿 메서드 패턴은 SubClassLogic1 , SubClassLogic2 처럼 클래스를 계속 만들어야 하는 단점이 있다.
  - 익명 내부 클래스를 사용하면 이런 단점을 보완할 수 있다
  - 그래서 익명 내부 클래스를 이용해서 templateMethodV2 test method를 만듬

- 중요 point
  - 익명 내부 클래스의 이름
    - TemplateMethodTest$1 , TemplateMethodTest$2 로 나옴
    - 즉 익명 내부 클래스를 사용한 **클래스$순서** 이런식

## 템플릿 메서드 패턴 - 적용1 (11)

- 개요
  - app -> trace -> template 에 AbstractTemplate abstract class 만듬
  - app -> v4 구현
  - 그냥 앞서 나온 템플릿 메소드 패턴을 적용한것이 전부

- point
  - 익명 inner class에서 AbstractTemplate abstract class의 contructor는 param 1개를 받는다
  - 그래서 아래처럼 trace 를 전달함

  ```java
  AbstractTemplate<String> template = new AbstractTemplate<>(trace) {
      @Override
      protected String call() {
          orderService.orderItem(itemId);
          return "ok";
      }
  };
  ```

  - AbstractTemplate<T>는 제네릭을 써서 만듬
  - Void 가 반환 타입일 경우 return null 해야 한다.

## 템플릿 메서드 패턴 - 적용2 (16)

- 개요
  - 앞서 적용한 내용을 정리 한것
  
- point
  - 좋은 설계란?
    - 코드 변경이 발생했을때 드러남
  - 단일책임원칙 (SRP)
    - 로그를 남기는 부분에 단일 책임 원칙(SRP)을 지킨 것이다. 변경 지점을 하나로 모아서
    - 변경에 쉽게 대처할 수 있는 구조를 만든 것이다

## 템플릿 메서드 패턴 - 정의 (18)

- 개요
  - 템플릿 메서드 패턴이 무엇인지 정리해줌
  - PDF 꼭 참조!!

- 중요
  - 상속의 단점이 나옴
    - 주요 단점은 부모 class가 변하면 자식 클래스에도 영향을 받음
  - 상속(템플릿 메소드 패턴) 보다 위임 (전략 패턴)을 다음 부터 소개함
  - 상속은 PDF에 나와 있듯 여러 단점이 있으므로.. 
  - > 보통 상속은 여기처럼 subclassing 보다는 sub-typing으로 쓰는것이 좋다고 했던거 같음.   
  - > sub-typing은 interface - impl 개념임. 
  - > subclassing : 코드 중복 제거, 재사용이 목표 ( 슈퍼 클래스를 대체하지 못함)
  - > sub-typing : 설계 유연성이 목표.

## 전략 패턴 - 시작 (19)

- 개요
  - 전략 패턴 소개를 위한 예제를 만듬
  - 기존 TemplateMethodTest class의 내용을 그대로 ContextV1Test로 가져옴
  - 앞으로 이것을 전략 패턴으로 푸는 방법을 소개 ( 앞선 챕터에서는 이걸 템플릿 메소드로 품 )

- 주요 포인트
  - 전략 패턴에서 Context란?
    - 거대한 문맥.. 그냥 템플릿 메소드 패턴에서의 템플릿 이라고 보면됨 ( 변하지 않는 로직 )
    - > 이중 일부의 알고리즘을 빼서 교체 가능하게 만드는게 전략 패턴.. 
  - 상속이랑은 다르게 interface에 의존하고 있어서 변경에 좀더 영향을 덜 받는다.
    - > 사실 인터페이스가 변경될 일은 부모 class가 변경될 일보다는 좀더 적으니까.. 
    - > 그리고 부모 class에는 logic이 있으니 이게 임의로 변경되면 자식에 영향이 갈수도 있는데  
    - > 인터페이스는 기본적으로 그럴일이 없음. 
  - 템플릿 메소드 패턴에서는 context가 부모 클래스에 있었는데, 전략은 따로 context가 빠져 있기 때문에
  - 이게 변하던 말던, 핵심 로직에는 영향을 주지 않는다.
  - > 강좌 10분쯤에 설명이 잘 나옴. 위 글만 봐서는 장점이 애매할수 있음

## 전략 패턴 - 예제1 (20)

- 개요
  - 전략 패턴 예제를 만듬(test code에 만듬)
  - test에 strategy package아래에 코드들을 둠

- 주요 포인트
  - ContextV1 은 변하지 않는 로직을 가지고 있는 템플릿 역할을 하는 코드이다. 
  - 전략 패턴에서는 이것을 컨텍스트(문맥)이라 한다.

## 전략 패턴 - 예제2

## 전략 패턴 - 예제3
