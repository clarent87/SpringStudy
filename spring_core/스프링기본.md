# 스프링 기본

스프링의 없던 시절의 코딩부터 진행한다함.

- PDF를 꼭 참고 하는게 좋다. 

> 중급편은 아직 안나온듯.
> 강좌가.. AOP는 설명이 없다. 

- [스프링 기본](#스프링-기본)
  - [객체 지향 설계와 스프링](#객체-지향-설계와-스프링)
    - [이야기](#이야기)
    - [스프링 이란?](#스프링-이란)
    - [좋은 객체 지향 프로그래밍 이란?](#좋은-객체-지향-프로그래밍-이란)
    - [좋은 객체 지향 설계의 5가지 원칙(SOLID)](#좋은-객체-지향-설계의-5가지-원칙solid)
    - [객체 지향 설계와 스프링](#객체-지향-설계와-스프링-1)
  - [스프링 핵심 원리 이해1 - 예제 만들기](#스프링-핵심-원리-이해1---예제-만들기)
    - [프로젝트 생성](#프로젝트-생성)
    - [비지니스 요구사항과 설계](#비지니스-요구사항과-설계)
    - [회원 도메인 설계](#회원-도메인-설계)
    - [회원 도메인 개발](#회원-도메인-개발)
    - [회원 도메인 실행과 테스트](#회원-도메인-실행과-테스트)
    - [주문과 할인 도메인 설계](#주문과-할인-도메인-설계)
    - [주문과 할인 도메인 개발](#주문과-할인-도메인-개발)
    - [주문과 할인 도메인 실행과 테스트](#주문과-할인-도메인-실행과-테스트)
  - [스프링 핵심 원리 이해2 - 객체 지향 원리 적용](#스프링-핵심-원리-이해2---객체-지향-원리-적용)
    - [새로운 할인 정책 개발](#새로운-할인-정책-개발)
    - [새로운 할인 정책 적용과 문제점](#새로운-할인-정책-적용과-문제점)
    - [관심사의 분리](#관심사의-분리)
    - [AppConfig 리팩터링](#appconfig-리팩터링)
    - [새로운 구조와 할인 정책 적용](#새로운-구조와-할인-정책-적용)
    - [전체 흐름 정리](#전체-흐름-정리)
    - [좋은 객체 지향 설계의 5가지 원칙의 적용](#좋은-객체-지향-설계의-5가지-원칙의-적용)
    - [IoC, DI 그리고 컨테이너](#ioc-di-그리고-컨테이너)
    - [스프링으로 전환하기](#스프링으로-전환하기)
  - [스프링 컨테이너와 스프링 빈](#스프링-컨테이너와-스프링-빈)
    - [스프링 컨테이너 생성](#스프링-컨테이너-생성)
    - [컨테이너에 등록된 모든 빈 조회 - 52p](#컨테이너에-등록된-모든-빈-조회---52p)
    - [스프링 빈 조회 - 기본 - 53p](#스프링-빈-조회---기본---53p)
    - [스프링 빈 조회 - 동일한 타입이 둘 이상 - 55p](#스프링-빈-조회---동일한-타입이-둘-이상---55p)
    - [스프링 빈 조회 - 상속 관계 -p57](#스프링-빈-조회---상속-관계--p57)
    - [BeanFactory와 ApplicationContext - 60p](#beanfactory와-applicationcontext---60p)
    - [다양한 설정 형식 지원 - 자바 코드,XML - 62p](#다양한-설정-형식-지원---자바-코드xml---62p)
    - [스프링 빈 설정 메타 정보 - BeanDEfinition - 64p](#스프링-빈-설정-메타-정보---beandefinition---64p)
  - [싱글톤 컨테이너 - 67p](#싱글톤-컨테이너---67p)
    - [웹 애플리케이션과 싱글톤](#웹-애플리케이션과-싱글톤)
    - [싱글톤 패턴 - 69p](#싱글톤-패턴---69p)
    - [싱글톤 컨테이너 - 71p](#싱글톤-컨테이너---71p)
    - [🤩 싱글톤 방식의 주의점 - p73](#-싱글톤-방식의-주의점---p73)
    - [@Configuration과 싱글톤 - 76p](#configuration과-싱글톤---76p)
    - [@Configuration과 바이트코드 조작의 마법 -80p](#configuration과-바이트코드-조작의-마법--80p)
  - [컴포넌트 스캔 (84)](#컴포넌트-스캔-84)
    - [컴포넌트 스캔과 의존관계 자동 주입 시작하기 (84)](#컴포넌트-스캔과-의존관계-자동-주입-시작하기-84)
    - [탐색 위치와 기본 스캔 대상 (90)](#탐색-위치와-기본-스캔-대상-90)
    - [필터 (92)](#필터-92)
    - [중복 등록과 충돌 (96)](#중복-등록과-충돌-96)
  - [의존관계 자동 주입 (97)](#의존관계-자동-주입-97)
    - [다양한 의존관계 주입 방법](#다양한-의존관계-주입-방법)
    - [옵션 처리 (102)](#옵션-처리-102)
    - [생서자 주입을 선택해라! (103)](#생서자-주입을-선택해라-103)
    - [롬복과 최신 트렌드 (105)](#롬복과-최신-트렌드-105)
    - [조회 빈이 2개 인상 - 문제 (109)](#조회-빈이-2개-인상---문제-109)
    - [@Autowired 필드 명, @Qualifier, @Primary (110)](#autowired-필드-명-qualifier-primary-110)
    - [애노테이션 직접 만들기 (114)](#애노테이션-직접-만들기-114)
    - [조회한 빈이 모두 필요할 때,  List, Map (115)](#조회한-빈이-모두-필요할-때--list-map-115)
    - [자동, 수동의 올마른 실무 운영 기준 (118)](#자동-수동의-올마른-실무-운영-기준-118)
  - [빈 생명주기 콜백](#빈-생명주기-콜백)
    - [빈 생명주기 콜백 시작 (120)](#빈-생명주기-콜백-시작-120)
    - [인터페이스 InitializingBeen, DisposableBean (124)](#인터페이스-initializingbeen-disposablebean-124)
    - [빈 등록 초기화, 소멸 메서드 (126)](#빈-등록-초기화-소멸-메서드-126)
    - [어노테이션 @PostConstuct, @PreDestroy (128)](#어노테이션-postconstuct-predestroy-128)
  - [빈 스코프 (131)](#빈-스코프-131)
    - [빈 스코프란?](#빈-스코프란)
    - [프로토타입 스코프 (132)](#프로토타입-스코프-132)
    - [프로토타입 스코프 - 싱글톤 빈과 함꼐 사용시 (138)](#프로토타입-스코프---싱글톤-빈과-함꼐-사용시-138)
    - [프로토타입 스코프 - 싱글톤 빈과 함꼐 사용시 Provider로 문제 해결 (145)](#프로토타입-스코프---싱글톤-빈과-함꼐-사용시-provider로-문제-해결-145)
    - [웹 스코프 (149)](#웹-스코프-149)
    - [request 스코프 예제 만들기 (151)](#request-스코프-예제-만들기-151)
    - [스코프와 Provider (156)](#스코프와-provider-156)
    - [스코프와 프록시 (158)](#스코프와-프록시-158)
  - [다음으로.. (162)](#다음으로-162)
  - [기타](#기타)

## 객체 지향 설계와 스프링

### 이야기

- EJB는 자바 진형 표준, 표준 구현체는 업체마다 있었나봄.
- EJB는 종합 선물세트. (ORM도 있음)
- EJB로 짜면?
  - EJB에 의존적으로 해야하고, 매우 지저분함, EJB 서버 비용도 비싸고..
  - EJB ORM은 수준이 낮음.
  - POJO로 돌아가자.. 라는 얘기까지 나옴.
- 현재
  - JPA는 표준 인터페이스
    - 구현체는
      - 하이버네이트 (이게 사실 JPA의 원조)
        - 현재도 JPA의 구현체는 80%이상 이걸씀.
      - EclipeLink, 등.

- 스프링 부트
  - 기본 스프링은 세팅이 어렵다.
  - 스프링으론 주로 web app개발
  - web app배포시 톰켓에 war를 넣고... 해야함. 불편

### 스프링 이란?

- 스프링은 여러 기술들의 모음
  - 스프링 프레임웤, 부트, (이 두개가 필수)
  - 스프링 데이터
    - CRUD를 편리하게 해주는거, 제일 많이 쓰는게 spring-data-jap
  - 스프링 세션
    - 세션기능을 편리하게 해주는거
  - 스프링 시큐리티, Rest Docs
  - 스프링 배치
    - 실무에선 data를 몇만건식 한번에 update하는 경우가 있다함.. 이건 실시간으로 못함
    - 여튼 이런 작업을 도와주는 것.
  - 이거 외에도 많다..

- 스프링 프레임워크
  - pdf 참조.

- 스프링 부트
  - 현재 모든 실무 프로젝트는 이거 깔고 들어감.

- 스프링 단어?
  - 스프링 단어는 문맥에 따라 다르게 사용됨
  - pdf 참조.

- 스프링을 왜 만들었나? 핵심 컨셉은?
  - 객체 지향
  - 스프링은 객체 지향 언어가 가진 강력한 특징을 살려내는 프레임워크
  - 스프링은 좋은 객체 지향 애플리케이션을 개발할수 있게 도와주는 프레임 워크
  - > 옛날 EJB시절에는 EJB를 상속받고.. 의존적으로 개발하다보면 객체지향의 장점을 모두 날려버리게 되었다함.
  - > 그래서 순수한 객체 지향으로 돌아가자는 POJO라는 단어도 나오고 했다함.. 그럴때 나온게 spring.
  - 스프링 DI 컨테이너가 여기서 큰 핵심임.

### 좋은 객체 지향 프로그래밍 이란?

- 역할,구현 구분.
  - > 뻔한 이야기이긴함. 역할은 interface, client는 interface를 사용하고있다면  
  - > interface 구현체를 변경해도 client는 변경 필요 없음

- 🌟 객체 설계시 인터페이스(역할)를 먼저 구현, 그뒤 구현(역할 수행)객체 만들기.
  - > 요게 핵심이라고 함.

- 객체의 협력 관계
- java는 실제 객체의 type에 해당하는 method가 호출.
  - > cpp는 실제 객체가 아닌 변수 type에 해당하는거 호출되었었음.  
  - > python도 실제 객체의 method호출
- 다형성의 본질
  - 인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경가능
  - 🌟클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경가능

- 역할 과 구현을 분리
  - 🌟인터페이스를 안정적으로 잘 설계하는 것이 중요!!
    - > java 인터페이스 뿐만아니라, client-server에서 api설계에서도 통용되는 말.
  - 확장 가능한 설계가 됨
    - > 그니까 구현체를 갈아 낄수 있음. 런타임에도.
  - 클라이언트에 영향을 주지 않은 변경 가능.

- 스프링과 객체 진향
  - 스프링은 다형성을 극대화 해서 이요할 수 있게 도와줌.
  - IoC, Di -> 다형성을 활용해서 역할과 구현을 편리하게 다룰수 있도록 지원

### 좋은 객체 지향 설계의 5가지 원칙(SOLID)

> UML쪽에도 정리 해뒀다.
  
- 클린코드 로버트 마틴이 정리 한것
  - SRP, OCP, LSP, ISP, DIP

- SRP (Single responsibility principle)
  - 한 클래스는 하나의 책임만 가져야한다.
    - 책임의 중요한 기준은 변경. 변경이 있을 때 파급 효과가 적으면 SRP 잘 따른것.
      - > 음.. 먼가 변경이 필요할때 해당하는 class 하나만 특정지어 변경할수 있으면 그게 SRP잘 따른거일듯..

- OCP (open-close principle)
  - 가장 중요한 원칙
  - 확장에는 열려있고 변경에는 닫혀 있어야한다.
  - > 인터페이스 기준으로 개발하면 기존 코드는 수정하지 않고 기능추가(확장) 가능하단거.. 근데 문제가 있음. 아래내용
  - 문제

    ```java
    MemberRepo m = new MemoryMemberRepo(); // 기존코드
    MemberRepo m = new JdbcMemberRepo();  // 변경코드
    
    // 즉 어쨋든, 그냥 java에서는 기존 코드 수정이 필요
    ```

  - 해결
    - 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요 => 스프링에서 DI, IoC, 컨테이너 가 관여 (clean-code 11장)

- LSP (Liskov substitution principle)
  - sub-typing 얘기.
  - 근데, 단순히 컴파일 성공을 넘어서는 이야기이다.
    - > 즉 method의 의미까지 어느정도 맞아야 함. 이를테면 액셀 기능이 있는데, 뒤로 가게 구현했다면 LSP위반.

- ISP (interface segregation principle)
  - 범용 인터페이스 대신, 역할당 인터페이스를 두는게 좋다.
    - > 이거 변경시 compile 문제랑도 엮임. UML에 작성핻둠.
    - 인터페이스가 명확해지고, 대체 가능성이 높아진다.

- DIP (dependency inversion principle)
  - 이것도 중요한 원칙
  - 프로그래머는 "추상화에 의존해야지, 구체화에 의존하면 안된다." -> TODO:이거 예시 다시 확인 필요. 그 pizzastore
    - 의존성 주입은 이 원칙을 따르는 방법 중하나.
  - > 추상화 된것은 구체적인 것에 의존하면 안된다.. 또는 고차원 적인 것이 저차원에 의존하면 안된다.  
    - >  ( 이거 고수준, 저수준.. 이거랑 다른 개념 이었던듯. )
  - > IoC랑 엮인 개념.
  - 역할에 의존하게 해야한다는 말.
  - > 🌟🌟어쨋든 강의에선 추상적인것(역할)에 의존해야한다는 말이라고 함. -> 그냥 이렇게 이해하는게 좋겠음. 아래 예시 참조
  - DIP 위반 예시

    ```java
    // classA
    MemberRepo m = new MemoryMemberRepo(); // classA는 MemberRepo 인터페이스에 의존하긴 하지만, 실제 구현에도 의존. 
                                      // TODO:이거 class diagram은 어케? ClassA는 MemberRepo랑 MemoryMemberRepo에 의존?연관?
    ```

- 🌟정리
  - 객체 지향의 핵심은 다형성
  - 다형성 만으로는 쉽게 부품을 갈아 끼우듯 개발 불가능
  - 다형성 만으로는 구현 객체를 변경할  때 클라이언트 코드도 함꼐 변경됨
  - **다형성 만으로는 OCP, DIP를 지킬수 없다.**
  - 뭔가 더 필요
    - > 객체 지향을 제대로 이해해서 개발했다면 이 결론엔 누구나 도달한다.  ( client 변경을 막을수 없다. )
    - > 이것 때문에 spring이 등장.

### 객체 지향 설계와 스프링

- 스프링은 다음 기술로 다형성 + OCP,DIP가능하게 지원
  - DI (Dependency Injection) : 의존관계, 의존성 주입
  - DI 컨테이너 제공
- 위 기술 활용해서 클라이언트 코드의 변경 없이 기능 확장 가능
- 순수하게 자바로 OCP, DIP 원칙들을 지키면서 개발을 해보면, 결국 스프링 프레임워크를 만들게 됨
  - 정확히는 DI 컨테이너.

- 정리
  - 이상적으로는 모든 설계에 인터페이스를 부여하자.
  - > 리팩토링이 빠르면, 그냥 구현만들고 필요시 리팩토링 하면될듯. 이내용 리팩토링책에 나오긴 했던거 같은데.. TODO:찾아보기
  - > 같은 내용이 아래 내용에 나오네..
  - 실무 고민
    - 하지만 인터페이스를 도입하면 추상화라는 비용이 발생
      - > 개발자가 코드를 볼떄, 추상화된것의 구현 class까지 한번더 봐야한다. 이게 비용  
      - > runtime 에 들어가는 객체 찾는것도 일일듯...
    - 🌟 기능을 확장할 가능성이 없다면, 구체 클래스를 직접 사용하고, 향후 꼭 필요할 때 리팩터링해서 인터페이스를 도입하는 것도 방법

## 스프링 핵심 원리 이해1 - 예제 만들기

### 프로젝트 생성

- 세팅
  - oracle jdk 의 java 11을 추천
  - 일단 spring boot의 dependency 아무것도 없이 project를 만들었음.
    - core 기능만 들어온 형태인데, 현재 예제에서는 하나도 쓰지 않을 예정 (즉 spring안씀)

### 비지니스 요구사항과 설계

- > TODO: 요구사항에 회원 VIP/일반 내용이 있던데.. 생각해보니 Visitor 예제가 기억남.. 이거 리팩토링 절차 가능한가?
- > 아직 정해지지 않은 요구사항은 interface로 만들면 된다.

### 회원 도메인 설계

> 보통은 아래 3가지 그리나봄

- 회원 도메인 협력 관계
  - > 기획자도 볼수 있는것.
- 회원 클래스 다이어 그램
- 객체 다이어 그램
  - > 서버가 실제 떠서 들어가는 객체 보여주기 위한것.  (클래스 다이어 그램만으로는 runtime 상태를 알수 없기 때문)

### 회원 도메인 개발

위의 class diagram 그대로 구현

- inteface files와 구현체 파일은 다른 패키지에 두는게 설계상 좋다.
  - > 강의에서는 그냥 simple하게 하기 위해 같은 패키징에 둠.

- > 오류 처리가 중요, 특히 db쪽. .근데 예제는 그냥함. 예제니까.
- > hashmap을 쓸때도, 실무에서는 concurrent HashMap씀.. 동시성 이슈 때문에

- 🌟네이밍. 구현체가 하나일 경우는 관례상 interface이름에 Imple을 붙임.
- 👍단축키, psvm, soutv 치면 된다. -> 자동으로 method 만들어줌

### 회원 도메인 실행과 테스트

> 별거 안함

### 주문과 할인 도메인 설계

> 별거 안함. pdf 참조, 역할을 통한 설계는 볼만함.

### 주문과 할인 도메인 개발

- 🤩 java 문법
  - <https://stackoverflow.com/questions/11408427/how-does-the-string-class-override-the-operator>
  - 예제에선 long 인 primitive 대신 Long을 쓰는데, 이유는 나중에 null을 넣을수도 있어서.. 그럼 primitive는 null 못넣음.

- 예제가 SRP 잘 지켜진 예시라고 함.

### 주문과 할인 도메인 실행과 테스트

> 별거 안함. TEST code랑 main 함수 만듬.

## 스프링 핵심 원리 이해2 - 객체 지향 원리 적용

요구사항이 추가되면서 DIP, OCP를 못지키게 되는 상황이오고,
이를 다양하게 해결하기 위해 노력  
그러다 보면 스프링의 핵심인 스프링 컨테이너가 왜 탄생했는지 알게됨.

### 새로운 할인 정책 개발

- TEST관련
  - `@DisplayName` junit5부터 지원되는것, 이거쓰면 test 의 이름이 DisplayName의 param으로 준 string으로 나옴
  - 🌟실패TEST는 꼭만들어 봐야 한다.
  - 🌟static method는 static import하는게 좋다.
  - 실무에서는 돈관련 Test는 경계값부터 해서 할수있는것은 다한다.

- 단축키
  - ctl + d : 라인복제

### 새로운 할인 정책 적용과 문제점

- 예시 문제 점
  - DIP, OCP 지킨거 같으나 아니다.
    - DIP : 추상class뿐아니라 concrete에도 의존하고 있음
    - OCP : client code 변경이 필요한 상태
  - OrderSeviceImpl은 concrete class에 의존하는 상태
    - 따라서 concrete class를 다른 concrete class로 변경시 OrderSercieImple의 변경은 필수.
      - > 의존하는 것의 변경이 있으면 client의 코드 변경은 당연

- 예시 해결 책
  - concrete class를 다른 곳에서 주입 해주면 된다.

### 관심사의 분리

🌟애플리케이션을 하나의 공연이라 생각해보자. 각각의 인터페이스를 배역(배우 역할)이라 생각하자. 그런데!
실제 배역 맞는 배우를 선택하는 것은 누가 하는가?

> 결국 객체를 세팅하는 관심사를 분리 -> clean-code( 11장 시스템 )

- 🌟추상적인 것의 의존하는 의미가 무엇인지, 생성자 주입이 무엇인지.  ( 8:26 )
  - > 추상적인 것 의존, MemberServiceImpl에 MemberRepository에 대한 concrete class 가 아예 등장 안함
  - > 생성자 주입 : 생성자를 통해 concrete class를 주입 받음.

- 단축키
  - cmd + e / ctl + e : 과거 history 보기

- > 🌟🌟class diagram  (15:00)
  - > 연관과 의존을 명확히 구분해서 쓰는듯.
  - > 이떄 스테레오 type은 UML에 소개된 대로 쓰긴 하는듯. pdf - 30p 참조
  - > 그뒤에 객체 diagram도 나오는데, 매우 중요

- Test Code
  - memberService 같은 instance 변수를 직접 초기화 하지 않고 ( 이건 초기화가 객체 생성 시점 한번)
  - `@BeforEach` 를 통해 초기화 하는 것이 좋다. (각 test case 돌기전 수행)

### AppConfig 리팩터링

- 🌟현재 AppConfig를 보면 중복이 있고, 역할에 따른 구현이 잘 안보인다. (35p-pdf)
  - > appconfig 같은 파일에서는 전체적인 class diagram 처럼 그림이 한눈에 들어와야 하나봄.
  - > 즉, appConfig에서 모든 애들의 역할들이 들어나게 하는 거이 중요

- 리팩토링 후..
  - AppConfig에 정의된  method만 봐도 시스템에 어떤 역할들이 존재하는지 확인 가능
  - 그리고 그 역할들의 실제 구현 (return문..) 이 무엇인지 확인가능
  - 변경시 return문만 수정해 주면됨
  - p35 - pdf의 diagram이랑 비교해서 보면 좋음.
  - 그리고
    - 🌟`new MemoryMemberRepository()` 의 중복 코드가 제거됨
      - > 중복 제거.. 리팩토링 책내용으로도 있었던거 같고,, 다른데도 나왔던거 같고..
  
### 새로운 구조와 할인 정책 적용

- 🌟사용영역 vs 구성영역 p38
  - > 나눠저 있어서 구성영역만 손보면 된다.

### 전체 흐름 정리

> 앞 내용 정리

### 좋은 객체 지향 설계의 5가지 원칙의 적용

> 별내용 없음

### IoC, DI 그리고 컨테이너

- 🌟 IoC 제어의 역전
  - 내가 코드를 호출하거나 제어하는게 아닌, framework가 하는것 pdf 42p 참조
  - ex. AppConfig가 모든 프로그램 흐름을 제어 ( 객체 주입을 통해, 그리고 client도 AppCofig를 통해 Service를 받아서 실행)

- 🌟 프레임웤 vs 라이브러리
  - Junit 같은거, 즉 프레임웤의 lifeCycle속에서 내 코드가 실행되는거(Test case) 이런 것들은 프레임웤이다.
  - 내가 직접 API를 호출하는 것은 라이브러리라고 한다.

- 🤩🤩 DI
  - 🌟 의존관계는 정적인 클래스 의존 관계와, 실행 시점에 결정되는 동적인 객체(인스턴스) 의존 관계 둘을 분리해서 생각해야 한다.
    - 정적인 클래스 의존
      - 이건 코드보고 바로 알수 있다, 그냥 class diagram이라고 보면됨
        - > 🌟 intellij diagram에서 show dependency 기능으로 볼수도 있다.
      - 근데 이것만 가지고는 실제 어떤 객체가 주입될지 알수 없음
        - > 근데 UML 에서 객체 다이어그램을 빈번히 그린다고 하지 않았다.
    - 동적인 객체 인스턴스 의존 관계
      - 객체 다이어그램
      - runtime에 결정
        - java 객체들은 참조로 연결됨
          - > primitive랑 참조의 세계라고 했음
          - > 즉 인스턴스 변수의 type이 primitive가 아니면 모두 참조
      - > 순환의존은 객체 다이어그램으로 찾아야 할듯
  - 의존관계 주입을 사용하면 정적인 클래스 의존관계를 변경하지 않고, 동적인 객체 인스턴스 의존관계를 쉽게 변경할 수 있다
    - 즉, 클래스 다이어그램은 전혀 변하지 않고, 기능을 변경할수 있음 (객체 다이어그램 변경)

- IoC 컨테이너, DI 컨테이너
  - "AppConfig" 처럼 객체를 생성하고 관리하면서 의존관계를 연결해 주는 것을 IoC 컨테이너 또는 DI 컨테이너라 한다.
    - Junit같은것도 IoC 컨테이너(범용적 용어) 이기 때문에 DI 컨테이란 용어를 만듬
      - > Junit은 DI를 해주진 않는다. IoC이긴하지만, AppConfig는 IoC, DI를 지원 그래서 DI 컨테이너란 용어 씀
  - 의존관계 주입에 초점을 맞추어 최근에는 주로 DI 컨테이너라 한다. 또는 어샘블러, 오브젝트 팩토리 등으로 불리기도 한다.
    - 어셈블러 : 애플리케이션 구성 "조립"을 한다고 해서 붙인 이름

### 스프링으로 전환하기

- `ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class);`
  - ApplicationContext가 Spring 컨테이너, 즉 bean들을 등록하고 관리, 이때 bean 등록은 AppConig.class에서 어노테이션 기반으로 찾아서 등록

- getBean 로 등록된 bean을 가져오는데, 기본적으로 `@bean`으로 등록되는 객체명은 `@bean`붙은 method명으로 등록됨
  - 그래서 param으로 메소드명 주고, return type class를 줌

- 실행하면 로그 뜸
  - `Creating shared instance of singleton bean 'appConfig'` 이런식으로 등록된 bean이 나옴 (이 앞 5개는 내부적으로 쓰는 bean이 등록됨)
    - appConfig 도 등록됨 `@Configuration` 붙어서 그런듯
    - 즉, key는 `@Bean` 붙은 method명(정확히는 Bean같은 어노테이션 붙은 애들일듯) value는 해당 method 반환 객체로 등록됨

- 스프링 컨테이너는 @Configuration 이 붙은 AppConfig 를 설정(구성) 정보로 사용한다 이렇게 스프링 컨테이너에 등록된 객체를 스프링 빈이라 한다.
- **스프링 빈은 @Bean 이 붙은 메서드의 명을 스프링 빈의 이름으로 사용한다**. ( memberService ,orderService )
  - `@Bean(name="mmm")` 이렇게 등록되는 method 명을 바꿀수도 있다.

- 🥇 단축키
  - ctl + space : code complete
    - > getBean("여기에서 쓰면 등록된 bean? 이름같은게 나옴.. 등록된 bean은 아닌거 같기도 하지만 여튼 뭔가 나옴")

코드가 약간 더 복잡해진 것 같은데, 스프링 컨테이너를 사용하면 어떤 장점이 있을까? => 엄청 많음..

## 스프링 컨테이너와 스프링 빈

pdf 49p부터..

### 스프링 컨테이너 생성

> 이쪽은 pdf가 정리 잘 되어 있다. 49p~

- 순서
  - 1.스프링 컨테이너 생성
  - 2. 스프링 빈 등록
  - 3. 스프링 빈 의존관계 설정 -준비
  - 4. 스프링 빈 의존관계 설정 -완료
    - > 🌟 AppConfig.class를 보면 의존 주입이 단순 자바 코드 호출 같지만 그게 아니라고 함  
    - > 뒤 싱글톤 설명에 나온다함
    - > ❓ 스프링은 빈 생성/의존주입이 나누어 져있다는데,, AppConfig같이 자바 코드로 스플이 빈을 등록하면 생성자를 호출하면서 param으로`memberRepository()` 같은 method 호출을 해서 의존이 주입됨.. 즉 의존 관계 주입까지 한번에 처리.. 의문점은 그럼 "스프링 컨테이너"의 " 스프링 빈 저장소"의 `MemoryMemberRepository`빈 객체랑, 실제 `MemberServiceImpl`에 의존 주입이된 `MemoryMemberRepository` 객체가 다른거 아닌가?
      - > 본예제와 같이 AppConfig로 직접 세팅하면,  spring 생성/의존이 한번에 됨. but spring lifecycle 은 나누어 져있음. 뒤에 자동 의존관계 세팅때 보면 안다함

- 주의: 빈 이름은 항상 다른 이름을 부여해야 한다. 같은 이름을 부여하면, 다른 빈이 무시되거나, 기존 빈을 덮어버리거나 설정에 따라 오류가 발생한다.
  - 👍 실무는 단순 명확해야 해서, 빈 이름이 중복되면 해결하려 하지 말고 무조건 중복안되게 하는게 좋다.  (실무에서 복잡한 시스템에서 bean 이름 충돌이 나기도 한다함.)
  - 최근 스프링 부트에서는 중복나면 기존 bean 객체를 덮는게 아니라 경고 주고 튕겨낸다.

- 👍 IDE 사용법
  - `public interface ApplicationContext`옆에 보면 fx라는 버튼이 나옴. 이거 누르면 구현체 list나옴

### 컨테이너에 등록된 모든 빈 조회 - 52p

- ApplicationContextInfoTest에 코드 작성

- Junit5부터는 class와 tast method 에 public 안써줘도 된다.
- 🌟🌟 단축키
  - iter를 입력하고 tab을 하면 iter가 정의된 변수가 있으면 그 변수로 자동으로 foreach만들어줌 (변수 바로 아래서 iter처줘야 하나?)
    - 또는 iterable 가능한 변수에다가 alt-enter하면 foreach로 해주는 선택 옵션이 있음
  - soutv, soutm
    - v는 변수명 println으로 쩍어주고, m은 메소드명..
    - 이것도 역시 target 변수 바로 아래에서 해줘야할듯..

### 스프링 빈 조회 - 기본 - 53p

- ApplicationContextBasicFindTest만듬
  - 코드에 주석 달았으니 참조.

- 🌟 단축키 cmd+E / ctl+E 파일 연 history나옴
  - > 이거 강사가 진짜 좋아하는 단축키라고 함 cmd + E 그리고 enter치면 바로 전 코드로 갈수 잇음

- `MemberServiceImpl memberService = ac.getBean("memberService", MemberServiceImpl.class);`
  - 이건 MemberServiceImpl.class라는 concrete class에 의존하고 있어서 좋지 않음
  - 🤩 무조건 역할(인터페이스)에 의존한는게 좋다.

- assertThrows
  - assertThrows는 junit에 있는거,  assertj가아니라..

### 스프링 빈 조회 - 동일한 타입이 둘 이상 - 55p

- 타입으로 조회시 같은 타입의 스프링 빈이 둘 이상이면 오류가 발생한다. 이때는 빈 이름을 지정하자.

- 같은 type의 bean이 등록될수 있다.
  - 즉, 등록되는 bean type이 같을수 있다는것, 이렇게 쓰는 경우가 있다
    - > 심지에 Impl type까지도 같을수 있다.
    - ex: 객체의 param만 다른 객체를 여러개 만들어서 bean에 등록하는경우
    - > 이 예제는 test code 주석에 달아둠

- 🤩 문법 static inner class
  - 이건 static inner class의 scope을 해당 outter class에서만 쓰겠다는것..
  - > 뭐 기본적으로 그렇다는 거겠지..

- `getBeansOfType`
  - 이걸로 여러개 반환된 bean을 Map으로 받을수 있음

### 스프링 빈 조회 - 상속 관계 -p57

- > ❓ 위에서는 빈 컨테이너에 등록된 실제 객체의 type이 중복이라는 거같기도..
  - >  여기는 자식들이 여러개인경우.. (interface의 imple도 자식으로 봄.)

🤩 이게 중요한 내용

- 🤩 대원칙
  - 부모 타입으로 조회하면, 자식 타입도 함께 조회한다.
- 🤩 문법
  - java는 눈에 보이지 않지만 모든 class는 Object를 상속하고 있다.

- 🤩 Test 짤대
  - 지금은 교육이라서 println하고 있는데, 실제 현업에선 println같은거 없어야함
  - 즉 test case는 통화 한다 안한다만 반환하고, test case는 ci/cd에 의해 자동으로 돌고 결과를 판별해야함. 즉 사람 눈으로 print된 값을 보고 있을순 없음.
  - 물론. test code를 디버깅할땐 남겨도 됨.

- > 일단 "동일한 타입이 둘 이상" 이랑 큰 차이가 없어보임..
  - > 내생각에  getBean을 concrete class로 조회시, 빈 컨테이너에 해당 type이 둘이상일때 case같고.. 물론 예시에선 interface로 조회해서 이 섹션과 별차이가 없어진거 같음.
  - > 이 섹션에선 상속 얘기이기 때문에 P class의 A, B가 빈 컨테이너에 있다면
    - > P로 조회시 A,B가 조회되니까 오류지만 (물론 getBeansOfType으로 다 받아오면 문제 없음. ) A 또는 B로 직접 조회하면 문제 없음

- 근데 사실 직접 getBean으로 빈객체를 받아올 일은 거의 없다. 이 섹션은 교육용

### BeanFactory와 ApplicationContext - 60p

- pdf 참조
- 위 섹션에서 사용한 getBean같은 것들은 bean factory가 제공하는 기능

- ApplicatonContext
  - 실제 application 구현에 필요한 여러 역할(인터페이스)를 상속하고 있음
    - MessageSource : 예를 들어서 한국에서 들어오면 한국어로, 영어권에서 들어오면 영어로 출력하는 web site 들 구현..에 씀
    - EnvironmentCapable :  로컬, 개발, 운영, (+스테이징)등을 구분해서 처리
      - 로컬 개발 환경
      - Test 서버 (개발 환경)
      - Production 환경 (운영 환경)
      - Staging 환경 : 운영과 가장 비슷한 밀접한 환경
      - 이때 각 환경별 DB는 다를수 있고(개발DB,운영DB) 이런걸 어떻게 연결해야 하는지 처리해 주는것
      - > <https://bcho.tistory.com/759>  => 운영환경
    - ApplicationEventPublisher : 이벤트를 발행하고 구독하는 모델을 편리하게 지원
    - ResourceLoader : 파일, 클래스패스, 외부 등에서 리소스를 편리하게 조회
    - > 🤩 위 부가 기능은 본 강의에는 강의하지 않음.. 내 생각엔 따로 찾아서 봐야 할듯

### 다양한 설정 형식 지원 - 자바 코드,XML - 62p

- 지금까지는 java 코드로 AppConfig.class를 만들어서 썻었음. xml로도 동일 기능 가능
  - > 과거엔 xml 썻는데, 현재는 java만 씀

- 최근에는 스프링 부트를 많이 사용하면서 XML기반의 설정은 잘 사용하지 않는다.
  - 아직 많은 레거시 프로젝트 들이 XML로 되어 있고,
  - 또 XML을 사용하면 "컴파일 없이" 빈 설정 정보를 변경할 수 있는 장점도 있으므로 한번쯤 배워두는 것도 괜찮다
  - > 강사는 최근 몇년간 쓴적이 없음

- java source가 아닌것들은 project folder에 있는 resources에 두면됨
  - 본 섹션 강좌의 xml같은 것도..

- 🤩 단축키
  - 폴더에다가 alt + inst 먹힐수 있음 ( new file, package 등 생성)
    - 원래 alt +inst는 class에서 constructor, get/setter만들때 사용

### 스프링 빈 설정 메타 정보 - BeanDEfinition - 64p

> 요번 챕터는 약간 교양이라고함.. 즉 몰라도 spring개발엔 지장은 없다함.

- BeanDefinition objcet 출력하면 나오는 속성 정보 (메타 정보. 이걸 기반으로 실제 instance를 생성)
  - scope : 이건 예제는 싱글톤이라 값이 없음
  - lazyInit : 이건 빈 객체가 실제 사용시 등록된다는것
  - factoryBeanName=appConfig;
    - > 추상 팩토리? 라고 봐야하나? 물론 appConfig는 추상은 아님
    - > 팩토리 class라고 보면될듯
  - factoryMethodName=memberService;
    - 팩토리 메소드가 memberService라는것, 즉 factoryBeanName의 factoryMethodName를 호출해서 해당 bean생성

- xml을 이용해서 등록하는 경우 BeanDefinition 속성이 쫌 다르다.
  - 🤩 AppConfig.class를 이용하는 경우는 **factory method**를 이용해서 등록하는 방법
  - xml의 경우 factory관련 정보는 없고, 실제 impl의 경로를 가지고 있음

- `getBeanDefinition` method 를 쓰려면 변수 type은  ApplicationContext가 아닌 concrete 구현체인 `AnnotationConfigApplicationContext` 여야함
  - 해당 method는 다른 interface에 역할(선언)이 있는거기 때문 `ApplicationContext`가 아니라..
  - > spring을 쓰는입장에서는 `getBeanDefinition`같은 복잡한 method를 쓸일이 없어서  `ApplicationContext`에는 없는거라고 함

## 싱글톤 컨테이너 - 67p

### 웹 애플리케이션과 싱글톤

- 스프링으론 웹 애플리케이션 뿐만아니라, 데몬 애플리케이션, 배치 애플리케이션 개발도 가능.
  - 근데 보통 웹 애플리케이션을 많이 씀

- 기존 웹 애플리케이션 문제
  - 웹 애플리케이션은 보통 여러 고객이 동시에 요청을 한다
    - > 즉 요청마다 객체를 만들어 주면 골치 아파짐
    - > 배민은 초당 TPS가 5만(과거에..). 즉 초당 5만개의 객체를 만들어야함.. 매우 비효율적..
  - 스프링 없는 순수 DI 컨테이너 인경우.. 위와 같은 문제 있다.
    - > 이거 예시로 나옴

### 싱글톤 패턴 - 69p

싱글톤 패턴으로 앞선 섹션의 문제를 해결

- 싱글톤 패턴
  - 관례상 아래과 같이 쓴다고함.

  ```java
  private static final SingletonService instance = new SingletonService();
  // 그리고 private 생성자.추가 (의외로  prviate 생성자를 자주 쓴다함.)
  // 그리고 static getInstance로 위 instance 반환
  ```

  - > 디자인 패턴책이랑 아주 약간 다름 final 붙은 부분이.. 이거 상수풀 등록, 그리고 final없으면 값 교체가 가능하니까.. 근데 디자인 패턴책 싱글톤은 왜 그랬지.. 옛날책이라.?
  - > 그리고 싱글톤 패턴의 객체는 classloader마다 다름.

- 🤩 잘 설계한 객체는 컴파일 오류많으로 왠만한 에러가 다 잡히게 하는것
  - > 싱글톤의 private 생성자.. 설명하다 나옴. private 생성자 쓰면 다른데서 new 못함

- junit에서 `isSameAs vs IsEqual`
  - isSameAs : 이건 객체 참조값 비교
  - IsEqual: 이건 java 의 equals method에의한 비교

- 🤩 강사는 test case하나 수정/개발 후 돌리고나면 습관적으로 해당 test class 전체를 돌림.
  - > 특정 test case개발 수정시 해당 test case가 속한 class가 오류가 날 확률이 높아서..

- AppConfig.class 내용들도 전부 singleton으로 변경 해주면 되나?
  - 그럴 필요 없음.. spring 컨테이너가 객체를 싱글톤으로 관리 해줌..

- 근데 요새 컴퓨터가 너무 좋아서, 객체를 1000개 생성 vs 싱글톤 큰 차이가 없다함..
  - 그리고 gc도 엄청 빨라서 잘 비교가 안되나봄.

- 예제 싱글톤은 간단하고 안전한 방법을 씀
  - lazy 초기화 하는 방법도 있음.
  - 즉 해당 객체 접근시 생성하는거,, 이거 내 디자인 패턴책엔 없었던거 같음.

- 🤩 싱글톤 패턴 문제점 pdf 71p
  - 싱글톤 패턴을 구현하는 코드 자체가 많이 들어간다.
  - 의존관계상 클라이언트가 구체 클래스에 의존한다. DIP를 위반한다.
  - 클라이언트가 구체 클래스에 의존해서 OCP 원칙을 위반할 가능성이 높다.
  - 테스트 하기 어렵다
    - 이미 객체가 fix됨. 생성자 param을 변경하던가.. 하는 유연한 test코드 작성 불가.
    - 원하면 해당 class의 getInstance 버전을 몇개 더 만들어야됨.
  - 내부 속성을 변경하거나 초기화 하기 어렵다.
    - > um.. 이부분은 설명이 안됨 잘. set/get만들면 속성변경 같은건 될거 같은데..
  - private 생성자로 자식 클래스를 만들기 어렵다.
  - 결론적으로 유연성이 떨어진다.
    - dependency injection이 안됨.
    - > 생성자 inject은 안되지.. static이면 변수 inject도안되나?  
    - > 먼가 spring은 bytecode 변조해서 inject하는게 아닌가.. ( 아니라고 소개한거 같음. )
  - 안티패턴으로 불리기도 한다.

🤩 스프링 컨테이너(싱글톤 컨테이너)는 위 싱글톤 단점을 모두 해결해줌..

### 싱글톤 컨테이너 - 71p

- 싱글톤 레지스트리

- > 싱글톤 컨테이너를 쓰면 spring 컨테이너가 자동으로 bean 객체를 싱글톤으로 관리..
  - > 이경우 bean 객체들을 직접 new로 만들순 있겠지만.. spring쓰는데 그렇게 쓰는일은 없다... 라는거 같음

- 🤩 앞쪽에서 AppConfing.class같은거 준비해서 spring쓰면 더 불편하지 않냐.. 란 질문이 나올수 있었다.
  - 근데 그럼에도 spring를 쓰면 훨씬 좋은 이유중 하나는 이 싱글톤 컨테이너임.
  - 이거 없으면 singleton적용하려면, 앞 섹션의 싱글톤 단점 전부 해결해야함.. 알아서..

- 참고: 스프링의 기본 빈 등록 방식은 싱글톤이지만, 싱글톤 방식만 지원하는 것은 아니다.
  - 요청할 때 마다 새로운 객체를 생성해서 반환하는 기능도 제공한다. ( 필요한 이유는 scope 강의에서 나온다함. )
    - > http 리퀘스트 요청 cycle? 을 맞추거나.. 뭐 그럴때 쓴다함.
  - 자세한 내용은 뒤에 빈 스코프에서 설명하겠다.

### 🤩 싱글톤 방식의 주의점 - p73

- **싱글톤 방식의 주의점**
  - 싱글톤 패턴이든, 스프링 같은 싱글톤 컨테이너를 사용하든,
    - 객체 인스턴스를 하나만 생성해서 공유하는 싱글톤 방식은 여러 클라이언트가 하나의 같은 객체 인스턴스를 공유하기 때문에 싱글톤 객체는 상태를 유지(stateful)하게 설계하면 안된다.
  - 무상태(stateless)로 설계해야 한다!
  - 특정 클라이언트에 의존적인 필드가 있으면 안된다.
  - 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다!
  - 가급적 읽기만 가능해야 한다.
  - 필드 대신에 자바에서 공유되지 않는, 지역변수, 파라미터, "ThreadLocal" 등을 사용해야 한다.
    - > java도 TLS 있나봄
  - 스프링 빈의 필드에 공유 값을 설정하면 정말 큰 장애가 발생할 수 있다!!
  - > 위 조건들은 java 스트림 쪽에도 비슷한 내용이 있었는데..

- 🤩🤩🤩 실무에서 상당히 자주 발생하는 예시 나옴. (StatefulService.class ,, test 코드쪽에 있음)
  - > 여튼 싱글톤 객체에서 stateful 변수 있으면 망한다는 말
  - > 멀티 쓰레드에서 문제 생길수 있는데, 이러면 에러 잡기 골때려진다함. ( 물론 멀티 쓰레드가 아닌 상황에서도 문제 발생함. )

- 🤩🤩🤩 진짜 공유필드는 조심해야 한다! 스프링 빈은 항상 무상태(stateless)로 설계하자.
  - > 실무에서 복잡한 상속 + 멀티 쓰레드까지 합쳐진 상태에서 이문제 터지면 잡기도 힘들고, log 다 까봐야하고
  - > 복구도 힘들로 날리난다함.
  - > 예제를 무상태로 변경하는 것은 쉬움 instance 변수 price를 두지 않고, 각 method에서 price를 반환하게 함.
  - > 이런거 refanctring 책에 있었나?

### @Configuration과 싱글톤 - 76p

> 여기 내용 중요한 point네, 앞에서 의문이었던것 해소됨

- `@Configuration`은 사실 싱글톤을 위해 존재하는것.
- 아래 내용 중요

  ```java
  // bean등록시 spring 컨테이너가  memberService , orderService method를 호출
  // 각각 memberRepository method가 호출되는데.. 이때 new MemoryMemberRepository() 가 호출됨.
  // 이떄 생성된 MemoryMemberRepository 객체는 두개일까? -> 즉 싱글톤 깨질까? -> test code로 증명
  @Bean 
  public MemberService memberService() {
      return new MemberServiceImpl(memberRepository());
  }

  @Bean
  public MemberRepository memberRepository() {
      return new MemoryMemberRepository();
  }

  @Bean
  public OrderService orderService() {
      return new OrderServiceImpl(memberRepository(), discountPolicy());
  }
  ```

- 예시에서 Test code를 짯는데, 이번 test를 위해 일부러 getBean에서 concrete class를 type으로 꺼냄.
  - 원래 getBean에서 concrete class를 type으로 줘서 꺼내는거 좋지 않다고함..

- 결론
  - 위 예시의 경우 각 method에 로그 넣고 실제 돌려보면, 아래와 같이 나옴.
  - 즉 config.class에 `@Bean`들에 대한 싱글톤이 보장됨

  ```java
    // call AppConfig.memberService
    // call AppConfig.memberRepository (한번만 찍힘)
    // call AppConfig.orderService
  ```

어떻게 싱글톤을 보장하는지 기술적인 내용은 아래 섹션에서 소개

### @Configuration과 바이트코드 조작의 마법 -80p

- `AnnotationConfigApplicationContext(AppConfig.class);`
  - AppConfig.class도 스프링 빈에 등록됨

- spring 컨네이너를 보면 AppConfig.class객체가 등록된게 아니라 spring이 CGLIB으로 조작한 AppConfig를 상속한 class의 객체가 등록됨
  - CGLIB : 바이트코드 조작 lib

- `@Configuration` 안 붙여도 되나?
  - 안붙여도 안에 있는 `@bean`붙은 것들 스프링 컨테이너에 등록해줌.
  - 🤩 단, 싱글톤 보장이 안됨
    - 즉, AppConfig.class를 CGLIB으로 전혀 조작하지 않음.
    - 즉, spring 컨테이너에 AppConfig 의 빈은 AppConfig type으로 잘 들어가고
    - 나머지 bean 들 등록은 java control-flow 그대로 진행됨.
      - 위 섹션 예에서 `call AppConfig.memberRepository`는 한번만 찍혔지만, 여기서는 3번이 찍힘.
      - 즉, memberService, memberRepository, orderService 빈 마다 각기 다른 memberRepository 객체가 생성됨
      - > 그리고 memberService, orderService에 주입된 memberRepository 객체는 bean이 아니다. 그냥 new로 만든 객체.
      - > `@Bean` 붙여서 만든 memberRepository메소드에 것만 bean에 등록됨

- AppConfig@CGLIB 예상 코드 -82p

- 결론
  - `@Configuration` 붙이면 `@Bean`붙은 것들은 싱글톤 보장이됨
    - 해당 method를 싱글톤 메소드로 치환해 주니까 CGLIB이..
    - psudo code는 82p에 있으니 참조 바람

## 컴포넌트 스캔 (84)

### 컴포넌트 스캔과 의존관계 자동 주입 시작하기 (84)

- 스프링은 설정 정보가 없어도 자동으로 스프링 빈을 등록하는 컴포넌트 스캔이라는 기능을 제공한다.
- 의존관계도 자동으로 주입하는 @Autowired 라는 기능도 제공한다

- 🤩 `@ComponentScan`
  - 이거를 config 파일에 붙여주면, 자동으로 class path에 있는 내용을 뒤져서 bean에 등록
    - `AnnotationConfigApplicationContext()` 에 confg파일을 넘겼다. test code에서 ApplicationContext 사용하기 위해..
      - > 뭐 이건 앞에서도 계속하던거.
    - > 이거 이용하면 config 파일 만들때 내부에 method만들고 `@Bean` 추가해주고 이럴 필요가 없음.   
    - > 그냥 path에 있는 class에 `@Component` 붙여주고 `@Autowired` 로 의존 관계 명시 해주면됨. 
  - 실제로 돌려보면 log로 scan정보 뜸
    - `ClassPathBeanDefinitionScanner ~`로 log가 시작
    - `Autowired` 정보도 나옴.

- `@Autowired`
  - 이전에 AppConfig에서는 `@Bean` 으로 직접 설정 정보를 작성했고, 의존관계도 직접 명시했다.
    - 이제는 이런 설정 정보 자체가 없기 때문에, 의존관계 주입도  `@Component`붙은 클래스 안에서 해결해야 한다.
    - 이때 `@Autowired`씀 (class의 생성자에 붙여줬다 - 생성자 주입)
  - 이거 붙은 경우, spring 컨테이너에서 같은 type인 빈을 찾아서 주입( 자식 type도 같은 type이다. )
    - ❓ 중복된 type들이 있다면? 무엇을 찾아서 주입? -> 뒤에서 소개
      - > 이거 안나오는거 같은데.. 
      - > 직접 찾았음 https://dbjh.tistory.com/24

- bean 이름
  - `@ComponentScan` 은 `@Component` 가 붙은 모든 클래스를 스프링 빈으로 등록한다.
  - **이때 스프링 빈의 기본 이름은 클래스명을 사용하되 맨 앞글자만 소문자**를 사용한다.
    - > 즉 빈 컨테이너의 key가 첫글자 소문자인 class명이라는거
    - > AppConfig.class에서 @Bean으로 직접 등록하였을땐 method 명이었음..
  - `@Component("memberService2")` -> 이렇게 해서 이름을 변경해 줄수도 있음.

### 탐색 위치와 기본 스캔 대상 (90)

- 탐색할 패키지 시작위치 지정

  ```java
  @ComponentScan(
    basePackages = "hello.core",
  )
  ```

  - > 이거 안쓰면 library부터 모든 java source를 다 뒤지나봄. but default 값이 있음.  
  - > 🤩🤩 아무런 시작위치가 지정되어 있지 않으면 `@ComponentScan`붙인 class의 package + 하위 package를 뒤짐
  
  ```java
  @ComponentScan( basePackageClasses = AutoAppConfig.class, )
  // 이건 AutoAppConfig.class의 package를 base로 해서 scan
  ```

- 권장하는 방법
  - 개인적으로 즐겨 사용하는 방법은 패키지 위치를 지정하지 않고, 
    설정 정보 클래스의 위치를 프로젝트 최상단에 두는 것이다. 최근 스프링 부트도 이 방법을 기본으로 제공한다.

- 🤩🤩 참고로 스프링 부트를 사용하면 스프링 부트의 대표 시작 정보인 `@SpringBootApplication` 를   
  이프로젝트 시작 루트 위치에 두는 것이 관례이다. (그리고 이 설정안에 바로 @ComponentScan 이 들어있다!)

- 컴포넌트 스캔 기본 대상
  - `@Component` `@Controlller` `@Service ` `@Repository` `@Configuration`
    - `@Component` 를 제외한 나머지 annotation은 `@Component`가 annotation 선언에 쓰이고 있다. 
    - 참고: 사실 애노테이션에는 상속관계라는 것이 없다. 그래서 이렇게 애노테이션이 특정 애노테이션을 들고
      있는 것을 인식할 수 있는 것은 자바 언어가 지원하는 기능은 아니고, 스프링이 지원하는 기능이다

- 컴포넌트 스캔의 용도 뿐만 아니라 다음 애노테이션이 있으면 스프링은 부가 기능을 수행한다
  - `@Controlller` `@Service` `@Repository` `@Configuration`
  - `@Repository` : 스프링 데이터 접근 계층으로 인식하고, 데이터 계층의 예외를 스프링 예외로 변환해준다.
    - 이거 같은 경우 DB를 쓸떄 A DB쓰다가 B DB를 썻을때 두개 DB의 예외가 다르면 난감해짐. 이런걸 스프링 예외로 추상화 해서 받아줌. 


### 필터 (92)

> 어노테이션 만드는 법은 따로 study 필요.


- `@ComponentScan`의 option
  - includeFilters : 컴포넌트 스캔 대상을 추가로 지정한다.
  - excludeFilters : 컴포넌트 스캔에서 제외할 대상을 지정한다.

- 예시
  ```java
      @ComponentScan(
              includeFilters = @Filter(type = FilterType.ANNOTATION, classes = MyIncludeComponent.class),
              // 필터를 만든건데, type은 ANNOTATION로 지정, 이는 ANNOTATION과 관련된 필터를 만든것
              excludeFilters = @Filter(type = FilterType.ANNOTATION, classes = MyExcludeComponent.class)
      )
  ```
  - 내가 만든 MyIncludeComponent 어노테이션이 달린 class는 컴포넌트 스캔에 포함되고
  - 내가 만든 MyExcludeComponent 어노테이션이 달린 class는 컴포넌트 스캔에서 제외

- FilterType은 5가지 옵션이 있다.
  - ANNOTATION
    - 기본값, 애노테이션을 인식해서 동작한다.
    - > 위예시에서는 이거 type 명시해 줬는데, 원래 이게 default라 명시 안해도 됨. 
  - ASSIGNABLE_TYPE: 지정한 타입과 자식 타입을 인식해서 동작한다.
    - > 즉 필터링할 class를 직접 지정
  - ASPECTJ: AspectJ 패턴 사용
  - REGEX: 정규 표현식
  - CUSTOM: TypeFilter 이라는 인터페이스를 구현해서 처리

- 예시 
  ```java
  @ComponentScan(
    includeFilters = { @Filter(type = FilterType.ANNOTATION, classes = MyIncludeComponent.class), },
    excludeFilters = { 
      @Filter(type = FilterType.ANNOTATION, classes =MyExcludeComponent.class),
      @Filter(type = FilterType.ASSIGNABLE_TYPE, classes = BeanA.class) 
      //예를 들어서 BeanA도 빼고 싶으면 위와 같이 추가
    }
  )
  ```

- 근데 사실 includeFilters는 쓸일이 거의 없다. excludeFilters는 가끔 있음 
  - 예시에서도  `@Configuration` 뺄려고 사용했엇음 (AutoAppConfig.class)


### 중복 등록과 충돌 (96)

컴포넌트 스캔에서 **같은 빈 이름**을 등록하면 어떻게 될까?  
  
- 자동 빈 등록 vs 자동 빈 등록
  - 이건 오류 메시지가 나옴. 즉 등록이 안됨 
- 수동 빈 등록 vs 자동 빈 등록
  -  경우 수동 빈 등록이 우선권을 가진다. (수동 빈이 자동 빈을 오버라이딩 해버린다.)
     -  log도 나옴

- 🤩 물론 개발자가 의도적으로 이런 결과를 기대했다면, 자동 보다는 수동이 우선권을 가지는 것이 좋다.
  하지만 현실은 개발자가 의도적으로 설정해서 이런 결과가 만들어지기 보다는 여러 설정들이 꼬여서 이런 결과가
  만들어지는 경우가 대부분이다! 그러면 정말 잡기 어려운 버그가 만들어진다. 항상 잡기 어려운 버그는 애매한 버그다.
  그래서 **최근 스프링 부트에서는 수동 빈 등록과 자동 빈 등록이 충돌나면 오류가 발생하도록 기본 값을 바꾸었다**
  - `spring.main.allow-bean-definition-overriding=true` 세팅을 application.properties에 넣으면 
  - **원래** spring의 동작을 함 (즉, 오버라이딩 )

- 🤩 단축키
  - cmd + b / ctr + b
    - Go to Declaration or Usage

> 개발 할때, 어설픈 추상화 같은거 쓰는것보다 그냥 명확하게 코딩을 하는게 좋다. 복붙을 하더라도..   
> 애매한게 있으면, 에러 발생시 잡기가 너무 어렵다. 

## 의존관계 자동 주입 (97)

### 다양한 의존관계 주입 방법

- 생성자 주입
  - 생성자 호출시점에 딱 1번만 호출되는 것이 보장된다.
  - 불변, 필수 의존관계에 사용
    - > 즉 생성자 주입을 사용할땐, final 변수인게 좋고, setter같은것은 없는게 좋다. (물론 final이면 setter가 의미 없지만.)
    - 🤩 가급적이면 생성자 주입시에는 null이 아닌 객체가 들어갈수 있도록 준비해야한다. 
  - 🤩 중요! 생성자가 딱 1개만 있으면 @Autowired를 생략해도 자동 주입 된다. 물론 스프링 빈에만 해당한다
    - > 요즘에는 이렇게 많이 씀

- 수정자 주입(setter 주입)
  - setter 만들고 거기다 `@Autowired`작성
  - 🤩 스프링은 두가지 lifecycle로 나눠짐
    - 스프링 빈 등록
    - 연관관계 자동으로 주입 
      - > 이때 setter의 `@Autowired`를 보고 주입
      - > 단 생성자 주입시에는 "스프링 빈 등록"시점에 일어날 수밖에 없음. 
  - 선택, 변경 가능성이 있는 의존관계에 사용 
    - 즉 빈이 컨테이너에 없어도 쓸수 있다. ( 이경우 null이겟지..)
      - > `@Autowired(required = false)` 이렇게 하면 선택적으로 추가됨 (있으면 추가 없으면 안추가. )
      - > 중간에 객체를 교체할고 싶다면 setter를 강제로 호출하면됨 (변경) -> 근데 이럴일을 거의 없다. 
    - 참고: @Autowired 의 기본 동작은 주입할 대상이 없으면 오류가 발생한다. 주입할 대상이 없어도 동작하게
      하려면 @Autowired(required = false) 로 지정하면 된다.(위에 썻음.)
  - 자바빈 프로퍼티 규약의 수정자 메서드 방식을 사용하는 방법이다.
    - > setter method 말함. , 이때 네이밍을 setFieldName 이렇게 해야 함. 

- 필드 주입
  - > 옛날에는 많이 썻다. 코드도 간결하고.. private에도 쓸수 있고.  
  - 🤩 현재는 권장하지 않음. 
    - mock으로 test하기가 너무 불편 (spring 컨네이너가 아닌, 순수한 자바로 test할 방법이 없음)
      - > 이경우 field 변경을 위해 setter를 만들어야하는데.. 이럴꺼면 setter주입을 쓰지.. 
      - > ❓  근데 field를 public으로 하면되지 않나? 자바빈 프로퍼티 규약 때문인가? 이 규약이 빈 컨테이너랑은 별 연관은 없는거 같은데.. 
  - 결론
    - DI 프레임워크가 없으면 아무것도 할 수 없다.사용하지 말자! 
      - >즉 순수test code를 짤수가 없음. 무조건 spring 컨테이너를 띄워야함. 
    - 그래도 사용하려면?
      - 애플리케이션의 실제 코드와 관계 없는 테스트 코드
        - ex
        ```java
        @SpringBootTest
        class CoreApplicationTests{

          	// 이거 Test 띄우면, Source 코드에서 컨테이너 Bean까지는 자동으로 할당하는듯.
            // 즉 Test code를 짤때, AnnotationConfigApplicationContext 같은걸로 직접 등록 없어도 되는거 같다.
	          // 이부분은 설명이 안되었음

          // 이럴때 씀, SpringBootTest있을때 test코드에서.. 
          @Autowired  OrderService orderService; 

          @Test
          void contextLoads(){
            orderService.createOrder(~~)
          }
        }
        ```
      - 스프링 설정을 목적으로 하는 `@Configuration` 같은 곳에서만 특별한 용도로 사용
  - 👍참고: 순수한 자바 테스트 코드에는 당연히 @Autowired가 동작하지 않는다. @SpringBootTest 처럼 스프링 컨테이너를 테스트에 통합한 경우에만 가능하다.
  - 참고: 다음 코드와 같이 @Bean 에서 파라미터에 의존관계는 자동 주입된다. 수동 등록시 자동 등록된 
    빈의 의존관계가 필요할 때 문제를 해결할 수 있다 -> ❓ (101)
    - > 일단 @Bean으로 빈을 수동 등록하면, 생성자의 파라메터 의존 주입은 그동안 자동으로 됬었음.. 이건 당연

- 일반 메서드 주입
  - > setter 주입과 유사
  - 한번에 여러 필드를 주입 받을 수 있다.
  - 일반적으로 잘 사용하지 않는다.

- 의존관계 주입은 스프링 컨테이너가 관리하는 Bean이어야 한다. 
  - 참고: 어쩌면 당연한 이야기이지만 의존관계 자동 주입은 스프링 컨테이너가 관리하는 스프링 빈이어야
    동작한다. 스프링 빈이 아닌 Member 같은 클래스에서 @Autowired 코드를 적용해도 아무 기능도동작하지 않는다.

### 옵션 처리 (102)

- 주입할 스프링 빈이 없어도 동작해야 할 때가 있다.
  - 그런데 @Autowired 만 사용하면 required 옵션의 기본값이 true 로 되어 있어서 자동 주입 대상이 없으면 오류가 발생한다.

- pdf 확인 - 103p

- > 🤩 Test 코드에서 @Configuration 없이 작성한 class를 사용하였는데, 싱글톤 보장이 안된다고 했었다. @Bean들..
- > 근데 @Autowired 는 잘 동작하나보다. (즉 쨋든 해당 class는 bean에 등록되므로 내부에 있는 @Bean, @Autowired는 처리하는것)
- > 싱글톤 보장이 안되는 것은 @Configuration 붙지 않은 class이기 때문에 안에 있는 method에 싱글톤 로직을 못넣어서 그런듯. 
  
> class가 빈으로 등록될때 `@Autowired` 붙은것들은 전부 호출되는듯

참고: @Nullable, Optional은 스프링 전반에 걸쳐서 지원된다. 예를 들어서 생성자 자동 주입에서 특정
필드에만 사용해도 된다.

### 생서자 주입을 선택해라! (103)

즉, 여러 주입 방식중 **생성자 주입** 을 쓰라는것

- setter 기반의 주입의 경우 Test code 를 짤떄 문제
  - 기본적으로 setter 기반 주입을 준비 했다면, 해당 class의 생성자는 마련되지 않음 (의존성을 setter로 자동주입할테니)
  - 이경우 순수 java test를 짜게 되면 해당 class의 default 생성자로 객체를 생성하므로.. 의존성이 주입되지 않아서 
  - null except 발생
  - 물론. test짜는 사람이 setter가 있는것을 인지하고, setter까지 호출하면 정상 동작하겠지만.. 해당 class를 정확히 이해하지 않는이상 이럴일은없다. 
  - 따라서 생성자에서 의존성 명시를 해서 test code짜는사람에게 의존성을 명확히 알려주는 것이 좋음

- final 키워드를 쓸수 있다. 
  - > pdf참조. final의 특징을 쓸수 있다는 것.
  - 수정자 주입을 포함한 나머지 주입 방식은 모두 생성자 이후에 호출되므로, 
  - 필드에 final 키워드를 사용할 수 없다. 오직 생성자 주입 방식만 final 키워드를 사용할 수 있다

- 정리
  - 생성자 주입 방식을 선택하는 이유는 여러가지가 있지만, 프레임워크에 의존하지 않고, 
    순수한 자바 언어의특징을 잘 살리는 방법이기도 하다.
  - 기본으로 생성자 주입을 사용하고, 필수 값이 아닌 경우에는 수정자 주입 방식을 옵션으로 부여하면 된다.
  - 생성자 주입과 수정자 주입을 동시에 사용할 수 있다.
  - 항상 생성자 주입을 선택해라! 그리고 가끔 옵션이 필요하면 수정자 주입을 선택해라.
    필드 주입은 사용하지 않는게 좋다.
    > 필드 주입을 사용하면, 수정할수 있는 방법이 없음. -> 변수가 private인경우 한정일듯.. 
    > 즉 test code는 spring 컨테이너 없이는 동작 불가

### 롬복과 최신 트렌드 (105)

- 🤩 막상 개발을 해보면, 대부분이 다 불변이고, 그래서 다음과 같이 생성자에 final 키워드를 사용하게 된다.
  - 근데 생성자 만들기도 귀찮다.. 

- 롬복
  - 게터, 세터 같은거 만들어줌. 생성자도 많들어 주고. 
  - 🤩이거 진짜 많이 쓴다함 실무에서

- 롬복 설치
  - pdf에도 있고
  - start.spring.io에서 스프링부트 프로젝트 만들떄 dependency로 주면됨
  - > 롬복 plugin은 번들로 ide에 들어가 있음

- `@RequiredArgsConstructor` 
  - 롬복 제공 어노테이션 
  - Class의 final field를 이용해서 consturctor 자동 생성
  - > 이거를 써서 생성자를 하나만 만들게 되면, Autowired없어도 생성자 주입가능. 
  - > 즉 final field만 만들어 두면 생성자를 타이핑 해줄 필요가 없다. 
  - > 🤩 이거 엄청 많이씀, 생성자자 직접 필요할때는 이거 없이 직접 생성자 만들어 준다. 
    - > final 변수를 중간 중간 추가하게 될떄 매우 편리

- 🤩 단축키
  - ctrl + F12 / cmd + F12 
    - 해당 class의 sturucture 보기 (근데 ide의 좌하단에도 있음)


- 정리
  - 최근에는 생성자를 딱 1개 두고, @Autowired 를 생략하는 방법을 주로 사용한다. 여기에 Lombok
    라이브러리의 @RequiredArgsConstructor 함께 사용하면 기능은 다 제공하면서, 코드는 깔끔하게
    사용할 수 있다.

### 조회 빈이 2개 인상 - 문제 (109)

> 앞에서 의문이었던거 해결해주는 섹션

- 🤩 실문에서는 git에서 코드 받으면, 무조건 test부터 돌리고 시작한다. ( 물론 젠킨스가 돌려주긴 하지만.. )

- 해당 type의 빈이 두개 등록되어있을때, Autowired를 쓰면
  - NoUniqueBeanDefinitionException 예외 발생 -> 이거 실무에서 생각보다 자주 나온다고함. 
  - > bean가져오기 위해 getBean했을 때도 이랬던거 같다. 찾아진 bean이 두개이상일때.. 

- 해결
  - 이때 하위 타입으로 지정할 수 도 있지만, 하위 타입으로 지정하는 것은 DIP를 위배하고 유연성이 떨어진다.
  - 그리고 이름만 다르고, 완전히 똑같은 타입의 스프링 빈이 2개 있을 때 해결이 안된다.
  - **스프링 빈을 수동 등록**해서 문제를 해결해도 되지만, 의존 관계 자동 주입에서 해결하는 여러 방법이 있다.
  - > 즉 위 해결책들은 좋지 않기 때문에 다음 섹션에서 해결책이 나온다. 
  
### @Autowired 필드 명, @Qualifier, @Primary (110)

여러개의 bean이 선택되어질때 어떻게 해결해야하는가? 3가지 방법이 있다. 

- @Autowired 필드 명 매칭
  - > 생성자 주입시 param의 변수명을 빈 컨테이너의 key와 매칭시킨다. 
  - 즉, autowired는 type으로 빈 컨테이너에서 빈들 찾고, 만약 여려개가 조회되면 변수 이름으로 비교해서 찾는다. 
- @Qualifier @Qualifier끼리 매칭 빈 이름 매칭
  - pdf참조.
  - 단순하게 설명하면 Qualifier를 class에 세팅할수 있음 (nickname같은거.. ) 이거를 autowired하는 변수 앞에 추가로 
    세팅해 줄수 있다. (이때 nickname은 class에 세팅했던 것 중하나를 쓴다. )
  - @Qualifier 로 주입할 때 @Qualifier("mainDiscountPolicy") 를 못찾으면 어떻게 될까? 
    그러면 mainDiscountPolicy 라는 이름(key값일듯.)의 스프링 빈을 추가로 찾는다
- @Primary 사용
  - 🤩 이거 자주 사용함
  - > 많이 쓰는 예시 곳? pdf에 설명 잘 나옴.
  - > 주로 main db(로직의 90%가 존재), sub db가 있다고 할때   
  - > main db커넥션을 primary로 두고 쓴다. sub db 커넥션은 Qualifier로 세팅해서 명시적으로 쓴다. 필요할땐

- 우선순위
  - spring은 넓은 선택 범위의 세팅 보다는, 좁은 선택범위의 세팅이 우선순위가 높다. 
  - 즉, Qualifier, Primary 두개 동시 사용시 Qualifier의 우선순위가 높음
- 🤩 단축키
  - cmd + option + b / ctl + alt + b
    - 해당 type의 구현체 list 보여줌. 이거 선택해서 구현체로 들어갈수도 있음


### 애노테이션 직접 만들기 (114)

- Qualifier("mainDiscountPolicy") 이렇게 문자를 적으면 컴파일시 타입 체크가 안된다.
  - 즉, 사용하는 측에서 Qualifier("mmmmainDiscountPolicy") 라고 오타를 내도 인식하기가 어려움.. 
  - 그래서 Qualifier가 붙은 어노테이션을 만들어서 씀. 
  - > 약간 상속처럼.. 상속은 아니지만.. (spring이 제공하는 기능)

- > 예제에 어노테이션 만들때, Qualifier 어노테이션에 붙어있는 어노테이션 문을 전부 복사해왔음

- 🤩 단축키
  - cmd + b / ctl + b 또는 cmd + 클릭 / ctr + 클릭
    - 해당 type의 usage들을 보여줌. 

애노테이션에는 상속이라는 개념이 없다. 이렇게 여러 애노테이션을 모아서 사용하는 기능은 스프링이
지원해주는 기능이다. @Qulifier 뿐만 아니라 다른 애노테이션들도 함께 조합해서 사용할 수 있다.
단적으로 @Autowired도 재정의 할 수 있다. 물론 스프링이 제공하는 기능을 뚜렷한 목적 없이 무분별하게
재정의 하는 것은 유지보수에 더 혼란만 가중할 수 있다

### 조회한 빈이 모두 필요할 때,  List, Map (115)

위와 같은 요구사항일땐

- 주입을 List, Map으로 받는다. 
  - pdf 117 참조

- 🤩 TDD
  - 일단 test 만들고, alt+enter로 빨간색 method를 만들수 있네. (이때 class 정도는 일단 준비되어야 하는듯.)

이렇게 동적으로 빈을 선택해야 할때 이렇게 Map으로 받아서 쓰면 편리. 

### 자동, 수동의 올마른 실무 운영 기준 (118)

컴포넌트 스캔이랑 자동 의존관계 주입에 대한 논의
- > 컴포넌트 스캔 : `@ComponentScan` 이거 달아서  AnnotationConfigApplicationContext 로 넣거나, `@SpringBootApplication` 로 실행하면 자동으로 `@component` 붙은거 bean으로 등록   
  - > 스프링부트는 컴포넌트 스캔을 기본으로 깔고감 (위 어노테이션.. )
- > 자동 의존 주입 : `@Autowired` 말함. 
  
기본적으로 자동으로 웬만하면 다 쓴다. 
  
- 🤩 설정 정보를 기반으로 애플리케이션을 구성하는 부분과 실제 동작하는 부분을 명확하게 나누는 것이
  이상적이지만, 개발자 입장에서 스프링 빈을 하나 등록할 때 @Component 만 넣어주면 끝나는 일을
  @Configuration 설정 정보에 가서 @Bean 을 적고, 객체를 생성하고, 주입할 대상을 일일이 적어주는
  과정은 상당히 번거롭다.
  - 그리고 설정 정보 관리하기도 번거롭고. 
- 결정적으로 자동 빈 등록을 사용해도 OCP, DIP를 지킬 수 있다
  
🌟 수동 빈 등록은 언제 사용하면 좋을까? -> pdf 꼭 참조
  
- 애플리케이션은 크게 업무 로직과 기술 지원 로직으로 나눌 수 있다
  - 업무 로직
  - 기술 지원 로직
    - AOP를 이용한 Log 출력 같은거.. 
  
🌟🌟 즉, 설정정보.class를 application root에 두는것이 좋다고 했는데, 여기서 추가적으로 기술지원 빈에 대한 설정정보를 해당 설정정보.class에 넣어두는 것이 좋다. 
  
**애플리케이션에 광범위하게 영향을 미치는 기술 지원 객체는 수동 빈으로 등록해서 딱! 설정 정보에 바로 나타나게 하는 것이 유지보수 하기 좋다.**  
  
비즈니스 로직 중에서 다형성을 적극 활용할 때도 수동 빈 등록 이용하면 좋다.  -> pdf 참조 바람. 
  
- 이경우 수동 빈으로 등록하거나 또는 자동으로하면 특정 패키지에 같이 묶어두는게 좋다! 핵심은 딱 보고
이해가 되어야 한다

- 정리
  - 편리한 자동 기능을 기본으로 사용하자
  - 직접 등록하는 기술 지원 객체는 수동 등록
  - 다형성을 적극 활용하는 비즈니스 로직은 수동 등록을 고민해보자

## 빈 생명주기 콜백

### 빈 생명주기 콜백 시작 (120)

스프링이 빈 생성시점, 소멸직전에 빈안에 있는 method를 호출해주는 기능.  

- 🤩 데이터 베이스 커넥션 풀, 또는 소켓
  - > 데이터 베이스 커넥션 풀은 현업에서 자주 쓴다. 애플리케이션 시작시 DB랑 연결을 해둠. 그리고 logic에서 이것들을 재활용. 
  - 이런것들은 애플리케이션 시작시 미리연결해야하고 종료 시점에 안전하게 연결 종료 필요


- 스프링 빈은 간단하게 다음과 같은 라이프사이클을 가진다.
  - 객체 생성 의존관계 주입
  - > 강의에서 세번째 언급 됨
  - > 앞쪽에서 생성자 주입은 어쩔수 없이 객체 생성과 의존 주입이 동시에 일어남

- 🤩 스프링 빈은 객체를 생성하고, 의존관계 주입이 다 끝난 다음에야 필요한 데이터를 사용할 수 있는 준비가 완료된다. 
  따라서 **초기화 작업**은 의존관계 주입이 모두 완료되고 난 다음에 호출해야 한다
  >  **초기화 작업** => 해당 객체로 network 연결 하거나.. 

- 그런데 개발자가 의존관계 주입이 모두 완료된 시점을 어떻게 알 수 있을까

- 🤩 스프링은 의존관계 주입이 완료되면 스프링 빈에게 콜백 메서드를 통해서 초기화 시점을 알려주는 다양한 기능을 제공 
-  스프링은 스프링 컨테이너가 종료되기 직전에 소멸 콜백을 준다. 따라서 안전하게 종료 작업을 진행할 수 있다.
   -  > 스프링은 스프링 컨테이너 종료되기 직전에 소멸 콜백 => 일반적인 싱글톤인 경우만.. 다른 scope같은 경우 다른 소멸 콜백을 받음


- 스프링 빈의 이벤트 라이프사이클 (싱글톤의 경우)
  - 스프링 컨테이너 생성 -> 스프링 빈 생성 ->  의존관계 주입(세터주입, 필드주입) -> 초기화 콜백 ->  사용 -> 소멸전 콜백 -> 스프링 종료
  - > 스프링 컨테이너가 내려가기 전에 소멸 콜백이 호출됨

- 🤩 참고: 객체의 생성과 초기화를 분리하자.
  -생성자는 필수 정보(파라미터)를 받고, 메모리를 할당해서 객체를 생성하는 책임을 가진다. 
  - 반면에 초기화는 이렇게 생성된 값들을 활용해서 외부 커넥션을 연결하는등 무거운 동작을 수행한다.
  - 따라서 생성자 안에서 무거운 초기화 작업을 함께 하는 것 보다는 
  - 객체를 생성하는 부분과 초기화 하는 부분을 명확하게 나누는 것이 유지보수 관점에서 좋다.
  - 물론 초기화 작업이 내부 값들만 약간 변경하는 정도로 **단순한 경우**에는 생성자에서 한번에 다 처리하는게 더 나을 수 있다.

- 스프링은 크게 3가지 방법으로 빈 생명주기 콜백을 지원한다.
  - 인터페이스(InitializingBean, DisposableBean)
  - 설정 정보에 초기화 메서드, 종료 메서드 지정
  - @PostConstruct, @PreDestroy 애노테이션 지원

- `ac.close(); //스프링 컨테이너를 종료, ConfigurableApplicationContext 필요, => 명시적 종료고 이러면 소멸전 콜백 확인가능`

### 인터페이스 InitializingBeen, DisposableBean (124)

> 이거는 스프링 초기에 나온 기술이라 현재는 안씀.  

등록될 bean class에 위 두개 impl해서 method override해주면 됨. 

- 단점
  - 이 인터페이스는 스프링 전용 인터페이스다. 해당 코드가 스프링 전용 인터페이스에 의존한다.
    - > 물론 spring을 쓰면 의존적으로 쓰긴 할텐데, 어노테이션이 아닌 interface까지 의존하는것은 부담되긴 한다. 
  - 초기화, 소멸 메서드의 이름을 변경할 수 없다.
  - 내가 코드를 고칠 수 없는 외부 라이브러리에 적용할 수 없다
    - > 즉 외부 라이브러리 class를 bean으로 수동등록했는데, 얘의 초기화/종료 코드를 무조건해야할때 호출해줄 방법이 없다. 

### 빈 등록 초기화, 소멸 메서드 (126)

설정 정보에 `@Bean(initMethod = "init", destroyMethod = "close")` 처럼 초기화, 소멸 메서드를
지정할 수 있다.

- 장점
  - 스프링 빈(NetworkClient.class)이 스프링에 전혀 의존하지 않음
  - 메서드 이름을 자유롭게 줄 수 있다.
  - 코드가 아니라 설정 정보를 사용하기 때문에 코드를 고칠 수 없는 
    외부 라이브러리에도 초기화, 종료 메서드를 적용할 수 있다.

- **종료 메서드 추론**
  - @Bean의 destroyMethod 속성은 default 가 `(inferred) ` 즉 추론
  - 이 추론 기능은 close , shutdown 라는 이름의 메서드를 자동으로 호출해준다. 이름 그대로 종료
    메서드를 추론해서 호출해준다.
  - 따라서 직접 스프링 빈으로 등록하면 종료 메서드는 따로 적어주지 않아도 잘 동작한다.
  - 추론 기능을 사용하기 싫으면 destroyMethod="" 처럼 빈 공백을 지정하면 된다.

- java 문법
  - 어노테이션 만들떄 아래와 같이 default keyword를 이상한 곳에 붙일수 있음 ( 어노테이션 안의 method에.. )
  - `String destroyMethod() default AbstractBeanDefinition.INFER_METHOD;`

> AutoClosable 공부해두면 좋다.   
> 이거  어디서 보긴 했는데.. -> 아.. try with resourece.. 

### 어노테이션 @PostConstuct, @PreDestroy (128)

셋 중에서 그냥 이거 쓰면 된다. 

- `import javax.annotation.PreDestroy;`
  - 패키지를 잘 보면 javax.annotation.PostConstruct 이다. 스프링에 종속적인 기술이 아니라 JSR-250라는 자바 표준이다.
  - 따라서 스프링이 아닌 다른 컨테이너에서도 동작한다.

- 유일한 단점은 외부 라이브러리에는 적용하지 못한다는 것이다. 외부 라이브러리를 초기화, 종료 해야 하면
@Bean의 기능을 사용하자
  

- 정리
  - @PostConstruct, @PreDestroy 애노테이션을 사용하자
  - 코드를 고칠 수 없는 외부 라이브러리를 초기화, 종료해야 하면 @Bean 의 initMethod , destroyMethod를 사용하자.


## 빈 스코프 (131)

### 빈 스코프란?

지금까지 우리는 스프링 빈이 스프링 컨테이너의 시작과 함께 생성되어서 스프링 컨테이너가 종료될 때
까지 유지된다고 학습했다. 이것은 스프링 빈이 기본적으로 싱글톤 스코프로 생성되기 때문이다. 스코프는
번역 그대로 빈이 존재할 수 있는 범위를 뜻한다. 
  
스프링은 다음과 같은 다양한 스코프를 지원한다.
- 싱글톤: 기본 스코프, 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프이다.
- 프로토타입: 
  - 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입까지만 관여하고 더는 관리하지 않는 매우 짧은 범위의 스코프이다.
  - > 즉 의존성 주입까지 해주고 떤지고 끝( 컨테이너로 관리 안해줌. )
- 웹 관련 스코프
  - request: 웹 요청이 들어오고 나갈때 까지 유지되는 스코프이다.
  - session: 웹 세션이 생성되고 종료될 때 까지 유지되는 스코프이다.
  - application: 웹의 서블릿 컨텍스트와 같은 범위로 유지되는 스코프이다.

Scope는 default가 싱글톤으로 세팅되어 있다. 

### 프로토타입 스코프 (132)

핵심은 싱글톤이랑은 다르게 spring 컨테이너에 빈이 등록되지 않는다는것.  
빈 요청때마다 빈 생성후 의존 주입후 반환까지만 해준다. 

> 싱글톤의 경우 bean 등록시에  초기화 콜백이 호출됨 
> 프로토타입의 경우 getBean해야 빈이 생성되니까. 이때 호출됨

- ` @Scope("prototype")`
  - 이건 bean 이 될 class에 달아 주는것.

- 특이사항
  ```java
  // SingletonBean.class를 param으로 전달시 component scan의 대상이 되어서 component scan이 됨.
  AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(SingletonBean.class);
  ```

- 싱글톤 빈은 스프링 컨테이너 생성 시점에 초기화 메서드가 실행 되지만, 프로토타입 스코프의 빈은 스프링
  컨테이너에서 빈을 조회할 때 생성되고, 초기화 메서드도 실행된다.

- 프로토타입 빈은 프로토타입 빈을 조회한 클라이언트가 관리해야 한다. 종료 메서드에 대한 호출도 클라이언트가 직접 해야한다.

- 정리
  여기서 핵심은 스프링 컨테이너는 프로토타입 빈을 생성하고, 의존관계 주입, **초기화**까지만 처리한다는것이다.
  
보통은 싱글톤빈만 쓰는데, 싱글톤빈이랑 프로토 타입 빈이랑 같이쓰면 중대한 문제가 발생함.. -> 다음 섹션에서 소개
 
### 프로토타입 스코프 - 싱글톤 빈과 함꼐 사용시 (138)


- clientBean 이라는 싱글톤 빈이 의존관계 주입을 통해서 프로토타입 빈을 주입받아서 사용하는 case (141)

> 쫌 뻔한 얘기인데.. 

- 🤩 단축키 
  - cmd + option +n / ctr + alt + n
    - > 이거 변수 인라이닝.. 


아마 원하는 것이 이런 것은 아닐 것이다. 프로토타입 빈을 주입 시점에만 새로 생성하는게 아니라, 사용할
때 마다 새로 생성해서 사용하는 것을 원할 것이다 -> 다음 섹션에서 설명한. 

```java
@Autowired ApplicationContext applicationContext; // 이렇게 해서 applicationContext를 주입 받을수도 있네.. 
```

### 프로토타입 스코프 - 싱글톤 빈과 함꼐 사용시 Provider로 문제 해결 (145)

싱글톤 빈과 프로토타입 빈을 함께 사용할 때, 어떻게 하면 사용할 때 마다 항상 새로운 프로토타입 빈을
생성할 수 있을까?  
  
1. ClientBean(싱글톤 빈)에서 logic api 호출시 getBean으로 컨테이너에 빈 생성요청
   ```java
    static class ClientBean {
      @Autowired  private ApplicationContext ac;
      
      public int logic() {
        PrototypeBean prototypeBean = ac.getBean(PrototypeBean.class);
        prototypeBean.addCount();
        int count = prototypeBean.getCount();
        return count;
      }
    }
    ```

🤩의존관계를 외부에서 주입(DI) 받는게 아니라 이렇게 직접 필요한 의존관계를 찾는 것을 Dependency
Lookup (DL) 의존관계 조회(탐색) 이라한다.  
  
그런데 이렇게 스프링의 애플리케이션 컨텍스트 전체를 주입받게 되면, 스프링 컨테이너에 종속적인 코드가
되고, 단위 테스트도 어려워진다.  
  
지금 필요한 기능은 지정한 프로토타입 빈을 컨테이너에서 대신 찾아주는 딱! DL 정도의 기능만 제공하는
무언가가 있으면 된다

- ObjectFactory, ObjectProvider
  - ObjectFactory 는 옛날꺼, ObjectProvider는 그거 확장한거, 편의기능이 추가됨
  - ObjectProvider를 이용하면 위섹션 문제가 해결됨 ( 즉 싱글톤에서 프로토타입 빈 사용할 때마다 새롭게 생성됨)
  - ObjectProvider의 핵심은 DL 기능을 제공해 준다는 것! ( 프로토타입 스코프만을 위한 것이 아님)
  - ObjectProvider는스프링이 제공하는 기능을 사용하지만, 기능이 단순하므로 단위테스트를 만들거나 
    mock 코드를 만들기는 훨씬 쉬워진다
  
> 예제에서는 ObjectProvider를 필드 주입 받았는데, 생성자 주입으로 해주는게 좋다고 함.   
> 🤩 ObjectProvider도 스프링 프레임웤에 의존적, 이거 import문으로 확인하네 -> 이렇게 의존확인하는거, 다른데도 나왔었는데.. 어디?

- JSR-330 Provider
  - 이건 Spring에 의존하지 않는 기술. JSR-330는 자바 표준 ( 컨테이너에서 뭘 가져올때 표준 )
  - `javax.inject:javax.inject:1` 라이브러리를 gradle에 추가해야한다. 
  - provider 의 get() 을 호출하면 내부에서는 스프링 컨테이너를 통해 해당 빈을 찾아서 반환한다. (DL)
  - 자바 표준이고, 기능이 단순하므로 단위테스트를 만들거나 mock 코드를 만들기는 훨씬 쉬워진다.
  - Provider 는 지금 딱 필요한 DL 정도의 기능만 제공한다.
  - 사용처 
    - > 표준이라서 Provider.java에 가보면 아래와 같이 작성되어 잇음
    - retrieving multiple instances ( 프로토 타입 예제 같은?? )
    - lazy or optional retrieval of an instance.
    - breaking circular dependencies. ( A->B, B<-A)
  
근데 현업에서 DL을 쓸일이 거의 없다고 함. 싱글톤으로 다 처리됨. 가끔 코드 분석할떄 사용 (외부 라이브러리 분석)  
근데 spring에서 중요 개념이긴 해서 소개함  
  
`@Lookup` 이용하는 방법도 있는데 생략됨 -> 잘 안쓰나봄
  
참고: 실무에서 자바 표준인 JSR-330 Provider를 사용할 것인지, 아니면 스프링이 제공하는
ObjectProvider를 사용할 것인지 고민이 될 것이다. ObjectProvider는 DL을 위한 편의 기능을 많이
제공해주고 스프링 외에 별도의 의존관계 추가가 필요 없기 때문에 편리하다. 만약(정말 그럴일은 거의
없겠지만) 코드를 스프링이 아닌 다른 컨테이너에서도 사용할 수 있어야 한다면 JSR-330 Provider를
사용해야한다.  
  
스프링을 사용하다 보면 이 기능 뿐만 아니라 다른 기능들도 자바 표준과 스프링이 제s공하는 기능이 겹칠때가 많이 있다.   
대부분 스프링이 더 다양하고 편리한 기능을 제공해주기 때문에,  
**특별히 다른 컨테이너를 사용할 일이 없다면, 스프링이 제공하는 기능을 사용하면 된다.**  
  
> JPA는 표준이 승리, 근데 위 내용은 Spring을 더 쓰지 표준을 잘 쓰지 않는다. 이건 Spring  전반에 걸처서 통용됨    
> 즉 대부분 표준 대신 Spring을 씀    
> 강사같은경우 Spring에서 표준을 쓰라고 명시한것들은 표준을 쓴다함 (ex: PostConstruct, PreDestroy)  
  
> TODO: ❓ 이쯤 해서 궁금해 지는데, auto bean등록할때 만약 생성자가 여러개면 어떻게 하지, 그리고 생성자에 param을 넘기고 싶을땐?
  > 주입된거 말고 나머지는 callback으로 세팅해야하나? "request 스코프 예제 만들기" 에서는 그런식으로.. 쫌 하는거 같음

### 웹 스코프 (149)

- 웹 스코프의 특징
  - 웹 스코프는 웹 환경에서만 동작한다.
  - 웹 스코프는 프로토타입과 다르게 스프링이 해당 스코프의 종료시점까지 관리한다. 따라서 **종료 메서드가 호출된다.**

- 웹 스코프 종류
  - request: HTTP 요청 하나가 들어오고 나갈 때 까지 유지되는 스코프, 각각의 HTTP 요청마다 **별도의 빈 인스턴스**가 생성되고, 관리된다.
  - session: HTTP Session과 동일한 생명주기를 가지는 스코프
  - application: 서블릿 컨텍스트( ServletContext )와 동일한 생명주기를 가지는 스코프
  - websocket: 웹 소켓과 동일한 생명주기를 가지는 스코프

> request scope일때 http 요청이 들어올시 Conetoller 빈에 의해 A 빈이 생성되어 사용된다면, 이건 이 scope안에서는 싱글톤으로 유지됨  
> 즉, 요청마다 생성되는 빈은 싱글톤으로 유지, 이때 다른 http요청이 온다면 이건 또 새로운 bean을 생성해서 전달   
> 이게 150p의 그림 내용  

### request 스코프 예제 만들기 (151)

동시에 여러 HTTP 요청이 오면 정확히 어떤 요청이 남긴 로그인지 구분하기 어렵다.  
이럴때 사용하기 딱 좋은것이 바로 request 스코프이다.

- `uuid = UUID.randomUUID().toString(); // 이거 글로벌하게 절대 곂치치 않은 UUID만들어줌`
  
예제 작성을 156p까지 하면 오류 발생!   
  
- 스프링 애플리케이션을 실행 시키면 오류가 발생한다. 메시지 마지막에 싱글톤이라는 단어가 나오고…  
  스프링 애플리케이션을 실행하는 시점에 싱글톤 빈은 생성해서 주입이 가능하지만, 
  request 스코프 빈은 아직 생성되지 않는다. **이 빈은 실제 고객의 요청이 와야 생성할 수 있다!**
  
그럼 이 오류는 어떻게 해결?  -> 다음. 섹션 내용
  

- 참고
  - requestURL을 MyLogger에 저장하는 부분은 컨트롤러 보다는 공통 처리가 가능한 스프링 인터셉터나 
    서블릿 필터 같은 곳을 활용하는 것이 좋다.   
    여기서는 예제를 단순화하고, 아직 스프링 인터셉터를 학습하지 않은 분들을 위해서 컨트롤러를 사용했다. 
    스프링 웹에 익숙하다면 인터셉터를 사용해서 구현해보자.

- LogDemoService
  - 비즈니스 로직이 있는 서비스 계층에서도 로그를 출력해보자
  - 🤩 여기서 중요한점이 있다. request scope를 사용하지 않고 파라미터로 이 모든 정보를 서비스 계층에 넘길수 있는데, 이러면
    파라미터가 많아서 지저분해진다. 더 문제는 requestURL 같은 웹과 관련된 정보가 웹과  관련없는 서비스 계층까지 넘어가게 된다.   
    웹과 관련된 부분은 컨트롤러까지만 사용해야 한다.  
    **서비스 계층은 웹 기술(ex: url정보?)에 종속되지 않고, 가급적 순수하게 유지하는 것이 유지보수 관점에서 좋다.**
    request scope의 MyLogger 덕분에 이런 부분을 파라미터로 넘기지 않고, MyLogger의 멤버변수에 저장해서 코드와 계층을 깔끔하게 유지할 수 있다.

### 스코프와 Provider (156)

- Provider이용하는 방법
- `myLoggerProvider.getObject(); ` 호출시 bean이 생성됨. 


> TODO: 근데 controller로 http 요청이 여럿 오면, 내부적으로 thead 만들어서 대응 해주나? ( 위처럼 동시에 빈이 여러개 생성되면 죽는거 아닌가?)

### 스코프와 프록시 (158)

- `@Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)`
  - 적용 대상이 인터페이스가 아닌 클래스면 TARGET_CLASS 를 선택
  - 적용 대상이 인터페이스면 INTERFACES 를 선택
  - > 프록시 패턴. 

- 스프링 컨테이너에 "myLogger"라는 이름으로 진짜 대신에 이 가짜 프록시 객체를 등록한다.
  > 근데 내부적으로 진짜로 등록되긴 한다는데.. (5:31초)

- 가짜 프록시 객체는 실제 request scope와는 관계가 없다. 그냥 가짜이고, 내부에 단순한 위임 로직만 있고, 싱글톤 처럼 동작한다
  > 가짜는 다같이 공유해도 된다는데..? (7:32초) -> 161p 그림

- 사실 Provider를 사용하든, 프록시를 사용하든 **핵심** 아이디어는 진짜 객체 조회를 꼭 필요한 시점까지 지연처리 한다는 점이다.

- 단지 애노테이션 설정 변경만으로 원본 객체를 프록시 객체로 대체할 수 있다. 이것이 바로 다형성과 DI 컨테이너가 가진 큰 강점이다.
  > 중급편 AOP의 원리와 동일.-> 가짜를 만들고 돌아간다. client를 전혀 고치지 않는다. 


주의점
마치 싱글톤을 사용하는 것 같지만 다르게 동작하기 때문에 결국 주의해서 사용해야 한다.
이런 특별한 scope는 꼭 필요한 곳에만 최소화해서 사용하자, 무분별하게 사용하면 유지보수하기
어려워진다. -> 테스트도 어렵다. 

## 다음으로.. (162)


- MVC강의
  - 예외처리는 어떻게 하는게 좋을지. 이런것도 나온다함. 

- JPA이용한 개발은..
  - JPA 실무 완전 정복 로드맵 다들어야 실무 활용가능
  - 그 중에서도 중요한것은 JPA활용 1 강의 => 꼭 듣기를 권장함

## 기타 

- test code에서 Scan 자동어떻게 하지?