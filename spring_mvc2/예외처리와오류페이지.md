# 예외처리와 오류 페이지

## 서블릿 예외처리 - 시작 (3)
  
스프링이 아닌 순수 서블릿 컨테이너는 예외를 어떻게 처리하는지 알아보자
  
- 서블릿은 다음 2가지 방식으로 예외 처리를 지원한다.
  - Exception (예외) 
    - > WAS, 서블릿 컨테이너 까지 예외가 날라갈때. 진짜 exception (ex: nullpointer)
  - response.sendError(HTTP 상태 코드, 오류 메시지)

- **오.. pdf 설명 매우 좋음. 꼭 확인 할것!! 👍**

- was까지 예외가 전달되었을떄
  -  tomcat이 기본으로 제공하는 오류 화면 확인 가능 -> status 500 page  
- `response.sendError(HTTP 상태 코드, 오류 메시지)`
  - 서블릿 컨테이너에게 오류가 발생했음을 전달함

## 서블릿 예외처리 - 오류 화면 제공 (6)

was default 오류페이지를, 그럴싸한것으로 변경하는 작업을 진행  

- 원리
  - 특정 에러,http status 코드 발생시 들어가야할 컨트롤러(uri)를 세팅함 WebServerFactoryCustomizer
  - 따라서 에러발생시 아래와 같이 동작함
    - 컨트롤러(예외) -> 인터셉터(예외) -> 서블릿(예외) -> 필터(예외) -> was(예외) 
    - -> 필터(uri) -> 서블릿(uri)  -> 인터셉터(uri)  -> 컨트롤러(uri) 

## 서블릿 예외처리 - 오류페이지 작동 원리 (10)

- 원리는 PDF에 잘나옴. 근데 위 설명한거랑 동일
- 추가적으로 WAS가 request.attribute에 담아주는 에러 정보를 찍어봄
  - WAS는 오류 페이지를 단순히 다시 요청만 하는 것이 아니라, 오류 정보를 request 의 attribute 에
    추가해서 넘겨준다

## 서블릿 예외처리 - 필터(13)

- 필터든 인터셉터든 예외처리시에는 두번 호출됨
  - 왜냐면 client가 request했을때 필터/인터셉터동작하고 컨트롤러에서 에러 발생해서 WAS로 내려갔을떄
  - WAS에서 등록한 예외처리 컨트롤러 호출하면 다시 필터/인터셉터 타고 가니까..
  - 근데 이거 비효율.. 로그인 같은거 생각해보면 이미 처리되었는데 또 처리할 필요가 없음
  - 또는 두번 호출되면 안되는 필터/인터셉터가 있을수 있음
  - 이런것을 처리하기 위해 DispatcherType을 WAS가 예외정보에 넣어서 올려준다. ( 등록한 예외 컨트롤러 호출할떄)

- FilterRegistrationBean으로 필터 등록시 setDispatcherTypes으로 필터가 동작하기를 원하는 DispatcherType을 지정할수 있음
  - > default는 REQUEST. 즉 원만하면 그냥 둬도 됨. 즉 특별히 오류 페이지 경로도 필터를 적용할 것이 아니면, 기본 값을 그대로 사용하면 된다

## 서블릿 예외처리 - 인터셉터 (17)

- 인터셉터 중복 호출 제거
  - > 위 필터 내용도 예외 flow때문에 중복 호출되는것을 제거하는 방법이었음
  - 별다른 방법이 있는것은 아니고 필터 등록시 
  - `excludePathPatterns("/css/**", "*.ico", "/error", "/error-page/**")` 를 이용해서 
  - 에러 처리 컨트롤러 경로 "/error-page/**" 를 exclude해준다. 즉 이경로로는 인터셉터 동작안함

PDF마지막에 필터,인터셉터 전체흐름이 정리되어 있음  
  
여기까지 다괜찮은데..   
WebServerFactoryCustomizer를 통해 오류페이지를 등록하는 과정이 불편.. -> 다음 장 주제

## 스프링부트 - 오류페이지 1 (21)

- tip
  - shift 두번 누르고 class 탭에서 BasicErrorController 검색하면 해당 코드 볼수 있음

- 내용상 오류페이지 자동으로 등록 생성에 대한 내용 ( 즉 restapi시 예외에 대한 내용은 아님)  
- controller에서 error 발생시 was가 /error 경로로 에러를 전파 하는듯.   
  - > 기존에는 에러 type 이나 상태코드에 따라 ErrorPage를 만들어서 등록했었음. 즉 이과정을 스프링 부트가 기본적으로 해주는거  

- > http://localhost:8080/error-ex 접근시 log에 예외 발생! 이 두번이나 뜨는데.. 왜지? 원래 그러나? 원래 그런거 같기도..
  - 로그상 내 인터셉터에서 한번 찍고, 디스패치서블릿에서도 한번 찍어주나봄

- 스프링 부트의 예외 처리시 뷰 선택 우선 순위 
  - pdf참조

## 스프링부트 - 오류페이지 2 (24)

- BasicErrorController가 제공하는 기본정보
  - 근데 기본적으로는 정보들이 나오지 않는다. 
    - 이런 정보를 client에 노출시킬 이유가 없어서. 그리고 해킹의 clue가 되기도 하니까
  - properties의 세팅을 통해 enable가능
    - > on_param 세팅은 특이하네.. 즉 request 호출시 `message=&errors=&trace=`를 넣어주면 에러 발생시 해당 내용들이 에러 페이지에 출력됨
      - 물론 error page는 개발자가 넣어주는거고 거기서 `${errors}` 등등 스프링 부트가 제공하는 변수를 써야 함.

- **사용자에게는 이쁜 오류 화면과 고객이 이해할 수 있는 간단한 오류 메시지를 보여주고 오류는 서버에 로그로 남겨서 로그로 확인해야 한다.**

- `server.error.path=/error` 
  - 오류 페이지 경로, 스프링이 자동 등록하는 서블릿 글로벌 오류 페이지 경로와 BasicErrorController 오류 컨트롤러 경로에 함께 사용된다.
  - 근데 이거 수정해서 쓸일은 없다고 함. 그냥 default 씀.

- 확장 포인트
  - 에러 공통 처리 컨트롤러의 기능을 변경하고 싶으면 ErrorController 인터페이스를 상속 받아서 구현하거나
  - BasicErrorController 상속 받아서 기능을 추가하면 된다.
  - > 즉 @Controller로 등록하기만 하면됨. --> 요거 특이하네. 이미 구현된 컨트롤러를 상속받아서 구현하는 point
  - > 상속시 protected 된 부분을 제어할수 있는 부분이 확장 포인트 인가봄
  - > 근데 크게 이렇게 쓸일은 없다고 함  
  - > TODO: 근데 bean이 두개가 등록되면 문제 아닌가? BasicErrorController는 우선 순위가 낮나?

## 정리

예외처리는 사실 두가지가 있음. 지금처럼 client에 웹페이지를 delivery하는경우. => 앞서 나왔듯 쉬움. /error 에 페이지 만들어주면 끝
그리고 다음에 나올 API일떄 => 어려움

- api는 기업간에 쓰는데, 이때 오류가 발생하면 어떤 형태로 오류 json을 보낼지 협의하고 보냄 -> 이거 복잡