# 타입컨버터

## 스프링 타입 컨버터 소개 (3)

- 4p 예 예시 오타

```java
/users/{userId}
@PathVariable("userId") Integer data // 오타 수정

```

## 타입 컨버터 - Converter (6)

타입 컨버터 인터페이스 구현하고, 직접 사용(test code)해보는 것 까지 진행 ( 아직 컨버터 등록하는것은 안함 )

> TODO 의문.  
> 아규먼트 리졸버랑 차이가 있나?  
> 예외는 어떻게 처리?

스프링은 용도에 따라 다양한 컨버터 제공 (11p)
> 자세한 내용은 spring 매뉴얼 참조 해야함. 나중에 꼭 확인해 볼것!!

## 컨버전 서비스 - Conversion Service (11)

conversionService에 컨버터 만든거 등록해서 사용하는 것 나옴

```java
// 일단 서비스에 컨버터 등록
// 실제 사용시 등록 부분은 따로 configuration에서 bean 등록을 해서 써야한다.
DefaultConversionService conversionService = new DefaultConversionService(); // ConversionService 구현체
conversionService.addConverter(new StringToIntegerConverter());
// 사용은 아래 처럼 함
IpPort ipPort = conversionService.convert("127.0.0.1:8080", IpPort.class); // 즉 source를 넣고, 반환으로 원하는 type을 명시해줌
                                                                            // 이러면 알아서 서비스에서 맞는 컨버터 찾아서 적용
```

- ISP 소개가 나옴
  - DefaultConversionService 같은경우 ConversionService, ConverterRegistry 두가지 인터페이스를 구현하고 있으므로
  - 사용하는 측에서는 `ConversionService service = new DefaultConversionService()`로 받아서 쓸수 있음
    - ( 물론, 빈 주입을 받아야 DefaultConversionService 의존이 없어짐)
    - > TODO: 빈 주입 interface 주입은 따로 알아봄
  - 즉 사용하는 측은 ConversionService만 의존하는 것이 가능
    - > 관련 내용은 UML에 있음
  - 이런것 처럼 spring에서는 객체 지향 solid 원칙이 잘 들어가 있다.
    - ex: 사용하는 쪽, 등록하는 쪽 인터페이스가 이런식으로 잘 분리된 케이스가 많다.

## 스프링에 Converter 적용하기 (14)

- @ModelAttribute에도 잘 적용된다고 함
  - > 아마 이경우는 ModelAttribute 적용되는 param 타입의 field에 적용된다는 것이겠지..
  - > 즉 쿼리 param 여러개(string 임)을 객체에 매핑할때 객체 field의 type을 보고 타입 컨버터 동작
  - > 그럼 @RequestBody에도 잘 동작할거 같음

- @RequestParam 은 @RequestParam 을 처리하는 ArgumentResolver 인 RequestParamMethodArgumentResolver 에서
  ConversionService 를 사용해서 타입을 변환한다

- 의문
  - @RequestBody에서 json를 객체에 매핑 해주던데. http메시지컨버터에 의한 동작.
  - 그럼 메시지 컨버터랑 타입 컨버터는 다른건가?? -> 다른거 같음
  - 핸들러 어댑터 -> argument Resolver ( return value handler)
    - argument Resolver에서 각종 어노테이션 처리함  ( return value handler)
    - 이떄 @RequestBody, HttpEntity 인 parm에 대해서는 http메시지 컨버터가 동작
    - @RequestParam의 경우 타입 컨버터 동작 => 이부분은 현재 예제를 보고 추론
  - > 즉 메시지 컨버터와 타입 컨버터는 다른 것이다. ( 메시지 컨버터는 interface가 타입 컨버터랑은 다름)

- tip
  - 스프링 코드 분석할땐 debug point걸어서 stacktrace를 보면서 분석하는게 좋다. ( 추상화가 잘 되어 있어서 그냥 소스 보기 어려움)
  - ex: 타입 컨버터 만든거에 bread point걸고 디버깅. 그럼 등록한 타입 컨버터 호출 시점에 break 걸림. 
  - 여기서 부터 stack을 봐서 어떤 어떤 method를 타고 왔는지 알수 있음

## 뷰 템플릿에 Converter 적용하기 (16)

- `"${{number}}"` 처럼 `{` 를 두개를 쓰면 타입 컨버터가 적용됨

```html
<ul>
    <!--  사실 숫자정도는 컨버터가 없어서 타입리프가 처리 해준다.-->
    <li>${number}: <span th:text="${number}"></span></li>
    <!-- number는 숫자인데 text로 출력하기 위해 타입 컨버터를  적용-->
    <li>${{number}}: <span th:text="${{number}}"></span></li> 
    <li>${ipPort}: <span th:text="${ipPort}"></span></li>
    <li>${{ipPort}}: <span th:text="${{ipPort}}"></span></li>
</ul>

```

- 폼에는 컨버터가 자동으로 적용 됨
  - `th:field` 에만 자동 적용 -> 코드 예시 참조
  - > `th:value` 는 타입리프 스프링 통합 기능은 아닌가봄

## 포맷터 - Formatter

## 포맷터를 지원하는 컨버전 서비스

## 포맷터 적용하기

## 스프링이 제공하는 기본 포맷터

## 정리
